<!doctype html>
<html lang="en">
<head>
<script>window.LAYOUT_MODE = window.LAYOUT_MODE || "traditional";
window.selectedStaffManager = window.selectedStaffManager ?? null;
window.addEventListener('load', () => {
  const t = document.querySelector('.header-title')?.textContent || 'OFFICE OF THE SECRETARY';
  setHeaderTitleText(t);
});
</script>

<script>var expandedSubleaders = window.expandedSubleaders || new Set(); window.expandedSubleaders = expandedSubleaders;</script>

<meta charset="utf-8">
<title> – Free Floating Starburst (Leaders + Staff)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>

<style>
@import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700&display=swap');


@import url('https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100&display=swap');

html,body{height:100%;margin:0}
body{
  background:
    radial-gradient(900px 600px at 15% 15%,rgba(96,165,250,.18),transparent 60%),
    radial-gradient(900px 600px at 85% 20%,rgba(56,189,248,.45),transparent 60%),
    radial-gradient(900px 600px at 65% 85%,rgba(245,158,11,.14),transparent 55%),
    linear-gradient(180deg,#0b1d36,#071427);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial;
  color:#f7fafc;
  overflow:hidden;
}
header{
  position:relative;
  z-index:1000;

  height:56px;
  display:flex;
  align-items:center;
  gap:14px;
  padding:0 16px;
  background:rgba(10,16,30,.65);
  border-bottom:1px solid rgba(255,255,255,.12);
  backdrop-filter:blur(12px);
}
header .spacer{flex:1}
button,label{
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.18);
  color:#fff;
  border-radius:10px;
  padding:8px 10px;
  font-weight:700;
  font-size:12px;
  text-transform:uppercase;
  letter-spacing:1.4px;
  cursor:pointer;
  transition:
    background-color 140ms ease,
    border-color 140ms ease,
    box-shadow 140ms ease,
    transform 140ms ease,
    width 220ms ease,
    max-width 220ms ease,
    filter 140ms ease;
}

button:hover,
label:hover{
  background:rgba(255,255,255,.12);
  border-color:rgba(255,255,255,.26);
  box-shadow:0 10px 22px rgba(0,0,0,.22);
  transform:translateY(-1px);
}

button:active,
label:active{
  transform:translateY(0px);
  box-shadow:0 6px 14px rgba(0,0,0,.18);
}

/* Top action buttons (right of search): NO lift; handled later in header override */
label input{display:none}
main{position:absolute;inset:56px 0 0 0;z-index:1}
#stage{position:relative;width:100%;height:100%;touch-action:none}
#viewport{position:absolute;inset:0;transform:translate(0px,0px)}
svg{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:0;
  overflow:visible;
}

#handlesSvg{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:5; /* above nodes */
  overflow:visible;
  pointer-events:none; /* don't block node dragging */
}
#handlesSvg .line-handle,
#handlesSvg .line-handle-hit{
  pointer-events:all !important;
}
.line{
  stroke:rgba(255,255,255,.35);
  stroke-width:2;
  fill:none;
  /* Critical: lines should not steal clicks/drags from nodes.
     Enable hit-testing only when explicitly editing lines. */
  pointer-events: none;
}

/* Only allow clicking/targeting lines when Line Edit mode is on */
body.line-edit .line{
  cursor:pointer;
  pointer-events: stroke;
}

/* In dept-focus, keep non-thread lines completely non-interactive even in line-edit */
body.dept-focus.line-edit .line:not(.focused-line){
  pointer-events:none !important;
}

.line-handle{
  pointer-events: all;
  cursor: grab;
}
.line-handle:active{ cursor: grabbing; }

.line-handle-end{ fill: rgba(56,189,248,.95); stroke: rgba(0,0,0,.45); stroke-width: 2; }
.line-handle-mid{ fill: rgba(255,255,255,.90); stroke: rgba(0,0,0,.45); stroke-width: 2; }

.line.root{ stroke: rgba(56,189,248,.55); stroke-width:2.6; }

.line-bus-guide{
  stroke: rgba(255,255,255,.22);
  stroke-width: 2;
  stroke-dasharray: 5 5;
}
.line-handle-bus{ fill: rgba(250,204,21,.95); stroke: rgba(0,0,0,.45); stroke-width:2; cursor: ns-resize; }
.line-handle-wp{ fill: rgba(147,197,253,.95); stroke: rgba(0,0,0,.45); stroke-width:2; }

#nodes{position:absolute;inset:0;z-index:1;pointer-events:none}

.node{
  position:absolute;
  transform:translate(-50%,-50%);
  cursor:grab;
  pointer-events:auto;
  user-select:none;
}
.node:active{cursor:grabbing}

:root{
  --size-staff: 54px;
  --size-subleader: 64px;
  --size-leader: 90px;
  --size-root: 150px;
}

.circle{
  width:var(--size-staff);
  height:var(--size-staff);
  border-radius:50%;
  background:#0b1220;
  border:4px solid rgba(156,163,175,0.65);
  overflow:hidden;
  display:grid;
  place-items:center;
  box-shadow:0 14px 26px rgba(0,0,0,.35), 0 0 0 2px rgba(255,255,255,.10);
  position:relative;
}
.circle-wrap{
  position:relative;
  display:inline-block;
  width:fit-content;
  height:fit-content;
}



.circle img{width:100%;height:100%;object-fit:cover;display:block;pointer-events:none;-webkit-user-drag:none;user-drag:none}
.initials{font-weight:900;letter-spacing:.5px}


/* --- Label styling: pill box emerging from behind circle --- */
.node{ --circle-size: var(--size-staff); }
.node.staff{ --circle-size: var(--size-staff); }
.node.subleader{ --circle-size: var(--size-subleader); }
.node.leader{ --circle-size: var(--size-leader); }
.node.root{ --circle-size: var(--size-root); }

.circle-wrap{ position:relative; z-index:2; }

.label{
  position:absolute;
  left:calc(var(--circle-size) / 2); /* box starts under circle (behind) */
  top:50%;
  transform:translateY(-50%);
  white-space:nowrap;
  pointer-events:auto;
  cursor:pointer;
  padding:0;
  z-index:1;
}

.label-box{
  display:inline-block;
  background:transparent;
  border:1px solid transparent;
  border-radius:28px;
  padding:16px 35px 16px calc((var(--circle-size) / 2) + 35px); /* 35px gap from circle edge to text */
  backdrop-filter:blur(1.5px);
  box-shadow:0 18px 40px rgba(0,0,0,.35);
}

.label-box:hover{
  background:rgba(5,10,20,.62);
  border-color:rgba(255,255,255,.16);
  }

/* Keep original label typography */
.label .dept{
  font-size:11px;
  letter-spacing:2px;
  text-transform:uppercase;
  color:rgba(56,189,248,.95);
  font-weight:900;
  margin:0 0 4px 0;
}
.label .name{
  font-weight:900;
  font-size:13px;
  line-height:1.15;
  margin:0 0 2px 0;
}
.label .title{
  font-size: 9px;
  letter-spacing:1.5px;
  text-transform:uppercase;
  color:rgba(247,250,252,.7);
  font-weight:500;
  line-height:1.15;
  margin:0;
}

/* Staff density tweaks (keep typography; slightly tighter padding) */
.node.staff .label-box{
  padding:10px 26px 10px calc((var(--circle-size) / 2) + 35px);
  border-radius:18px;
  box-shadow:0 12px 26px rgba(0,0,0,.28);
}

/* "Open card" hint: hover-only, above the text box (matches expand hint style) */
.label .card-hint{
  position:absolute;
  top:-34px;
  left:50%;
  transform: translateX(-50%) translateY(6px);
  opacity:0;
  pointer-events:none;
  background: rgba(0,0,0,0.72);
  color:#fff;
  padding:6px 8px;
  border-radius:999px;
  font-size: 8px;
  font-weight:700;
  white-space:nowrap;
  box-shadow:0 10px 18px rgba(0,0,0,0.22);
  transition: opacity 120ms ease, transform 120ms ease;
  z-index:20;
}
.label .card-hint::after{
  content:"";
  position:absolute;
  left:50%;
  bottom:-6px;
  transform:translateX(-50%);
  width:0;
  height:0;
  border-left:6px solid transparent;
  border-right:6px solid transparent;
  border-top:6px solid rgba(0,0,0,0.72);
}
.label-box:hover + .card-hint{
  opacity:1;
  transform: translateX(-50%) translateY(0);
}

.name{font-weight:900;font-size:13px}
.title{font-size:11px;color:rgba(247,250,252,.7)}

.node.selected .circle{
  box-shadow:0 0 0 4px rgba(245,158,11,.8),0 0 26px rgba(245,158,11,.6);
}

.node.fade-out{opacity:0.1;transition:opacity .25s ease}
.node.zoom-root{animation:zoomIn .35s ease}
@keyframes zoomIn{from{transform:translate(-50%,-50%) scale(.85)}to{transform:translate(-50%,-50%) scale(1)}}




/* --- WYSIWYG authoring additions --- */
#loadLayoutLbl{display:inline-flex;align-items:center;gap:8px}
#toast{
  position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
  z-index:6000;
  background:rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.18);
  padding:10px 12px;border-radius:12px;
  backdrop-filter:blur(10px);
  font-size:12px;opacity:0;pointer-events:none;
  transition:opacity .18s ease, transform .18s ease;
}
#toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}


/* --- Dept close button fix --- */
.node .dept-close{
  z-index: 10;
  pointer-events: auto;
}


.dept{font-size:11px;opacity:.55;margin-top:2px}

header{
  min-height:96px; /* doubled header height */
  display:flex;
  align-items:center;
}
header img{
  height:56px; /* scale logo up for taller header */
}

/* --- Hamburger menu (moves all header controls except Reset Layout) --- */
.hamburger{ position:relative; }
#hamburgerBtn{
  width:44px; height:44px;
  display:grid; place-items:center;
  font-size:22px;
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.18);
  border-radius:10px;
}
#hamburgerBtn:hover{ background:rgba(255,255,255,.12); }
.hamburger-menu{
  position:absolute;
  right:0;
  top:calc(100% + 10px);
  min-width:240px;
  background:rgba(10,16,30,.95);
  border:1px solid rgba(255,255,255,.18);
  border-radius:14px;
  padding:10px;
  display:none;
  z-index:6000;
  backdrop-filter:blur(12px);
  box-shadow:0 18px 40px rgba(0,0,0,.45);
  /* never force internal scrolling */
  max-height:none;
  overflow:visible;
}
.hamburger-menu.open{ display:block; }
.hamburger-menu button,
.hamburger-menu label{
  display:flex;
  width:100%;
  justify-content:flex-start;
  margin:6px 0;
}
.hamburger-menu label{ cursor:pointer; }
.hamburger-menu label input{ display:none; }

/* "Disabled" look without disabling click (used for Traditional-only tools) */
.soft-disabled{
  opacity:.45;
  filter:grayscale(1);
}
.soft-disabled:hover{
  background:rgba(255,255,255,.10);
  border-color:rgba(255,255,255,.20);
}


#searchInput::placeholder{color:rgba(247,250,252,.6)}
#searchInput:focus{box-shadow:0 0 0 3px rgba(96,165,250,.35)}


/* --- Density reduction --- */
.circle{width:50px;height:50px}


/* Ensure Back button never appears in hamburger */
#backBtn{display:none !important;}


/* --- Proximity glow effect --- */
.circle{
  transition: box-shadow .15s ease, border-color .15s ease;
}
.circle.glow{
  box-shadow:
    0 0 0 3px rgba(96,165,250,.6),
    0 0 18px rgba(96,165,250,.55);
}


/* --- Fixed header instructions --- */
#instructions{
  position:fixed;
  top:96px; /* under header */
  left:16px;
  z-index:900;
  width:auto;
  max-width:170px;
  font-size:11px;
  line-height:1.45;
  color:rgba(247,250,252,.8);
  background:rgba(10,16,30,.55);
  border:1px solid rgba(255,255,255,.12);
  border-radius:12px;
  padding:10px 12px;
  backdrop-filter:blur(10px);
}
#instructions strong{
  font-weight:800;
  font-size:11px;
  color:#fff;
}


/* --- Smooth zoom --- */
#viewport{
  transition: transform 120ms ease-out;
}


/* --- Search disambiguation overlay --- */
#searchOverlay{position:fixed;inset:0;z-index:7500;display:none;}
#searchOverlay.open{display:block;}
#searchResults{
  position:fixed;
  width:420px;
  max-width:calc(100vw - 32px);
  background:rgba(10,16,30,.98);
  border:1px solid rgba(255,255,255,.18);
  border-radius:12px;
  overflow:hidden;
  box-shadow:0 18px 40px rgba(0,0,0,.45);
}
.search-item{padding:10px 12px;cursor:pointer;font-size:12px;line-height:1.25;}
.search-item.active{background:rgba(96,165,250,.28);} 
.search-item:hover{background:rgba(96,165,250,.18);}
.search-item strong{font-weight:800;}
.search-item .meta{opacity:.65;margin-top:2px;font-size:11px;}


#viewport{transform-origin:0 0;}

/* --- Department hierarchy tweak --- */
.dept{
  color: rgba(56,189,248,.9); /* same green family as root lines */
  font-weight: 800;
  letter-spacing: .6px;
  font-size: 10px;
  opacity: 1;
  margin-bottom: 2px;
}


/* --- Department label typography refinement --- */
.dept{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  font-weight: 700;
  font-stretch: condensed; /* supported where available */
  letter-spacing: .8px;
  text-transform: uppercase;

  max-width: 140px;
  white-space: normal;
  word-break: break-word;
  line-height: 1.15;
}


/* --- Text wrapping + subtle text shadow refinement --- */

/* Ensure department names wrap only at word boundaries */
.dept{
  word-break: normal;
  overflow-wrap: normal;
  hyphens: none;
}

/* Subtle text shadow for readability (all labels) */
.name,
.title,
.dept{
  text-shadow: 0 1px 2px rgba(0,0,0,.45);
}


/* --- Reduce department label size on chart --- */
.dept{
  font-size: 9px;      /* slightly smaller */
  letter-spacing: .7px;
  margin-bottom: 1px;
}


/* --- How to use panel (border + grow) --- */
#instructions.howto{
  position:fixed;
  top:116px;              /* below header */
  left:16px;
  z-index:900;
  width:auto;
  max-width:170px;
  font-size:10.5px;
  line-height:1.45;
  color:rgba(247,250,252,.9);

  /* match header button outline + hover feel */
  background-color: rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.35);
  border-radius:10px;
  padding:10px 12px;

  backdrop-filter: blur(6px);

  transition:
    background-color 140ms ease,
    border-color 140ms ease,
    box-shadow 140ms ease,
    transform 140ms ease,
    filter 140ms ease;
}
/* Disable backdrop blur on HOW TO USE pill (prevents connector glow bleed) */
#instructions.howto{
  backdrop-filter: none;
  -webkit-backdrop-filter: none;
}
#instructions.howto:hover{
  background-color: rgba(255,255,255,.18);
  border-color: rgba(255,255,255,.26);
  box-shadow:0 10px 22px rgba(0,0,0,.22);
  transform:none;
}

.howto-toggle{
  display:flex;
  align-items:center;
  gap:8px;
  cursor:pointer;
  user-select:none;
}
.howto-icon{
  width:18px;
  height:18px;
  border-radius:50%;
  border:1px solid rgba(255,255,255,.9);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-weight:900;
  font-size:12px;
  line-height:1;
}
.howto-title{
  font-weight:800;
  letter-spacing:1px;
  font-size:10px;
}

/* Grow/collapse animation */
.howto-body{
  font-size:10.2px;
  max-width:260px;
  color:rgba(247,250,252,.85);
  text-shadow:0 1px 2px rgba(0,0,0,.45);

  overflow:hidden;
  max-height:0;
  opacity:0;
  margin-top:0;
  transform:scaleY(.98);
  transform-origin: top;
  transition:
    max-height 220ms ease,
    opacity 180ms ease,
    margin-top 180ms ease,
    transform 220ms ease;
}

#instructions.open .howto-body{
  max-height:520px;
  opacity:1;
  margin-top:8px;
  transform:scaleY(1);
}
/* Expand container width only when open */
#instructions.open.howto{
  max-width:340px;
}



/* --- Header layout fixes --- */
.header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  position:relative;
}

.header-left{
  display:flex;
  align-items:center;
  gap:12px;
}

.header-right{
  display:flex;
  align-items:center;
  gap:8px;
}

/* Force search to sit flush against right-side buttons */
.header-right .search-wrap,
.header-right .header-search{
  margin-right:0 !important;
  margin-left:0 !important;
}

/* Center title */
.header-title{
  line-height:1.05;
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  font-weight:900;
  letter-spacing:2px;
  font-size: clamp(26px, 4.6vw, 72px);
  opacity:.9;
  pointer-events:none;
  max-width: calc(100vw - 180px);
  white-space: nowrap;
  overflow: hidden;
}


/* --- Header title + search alignment (override) --- */
header{
  display:flex;
  align-items:center;
  gap:12px;
}
.header-title{
  position:static !important;
  transform:none !important;
  font-weight:300;
  font-size:32px;           /* ~2x previous */
  letter-spacing:1.6px;
  opacity:.9;
  line-height:1;
  white-space:nowrap;
}

/* Push search + buttons to the right */
#searchInput{
  margin-left:auto;
}


/* --- Header alignment hard fix --- */
header{
  display:flex;
  align-items:center;
}

.header-title{
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  font-weight:300;
  font-size:32px;
  letter-spacing:1.4px;
}

/* push search + buttons to far right */
#searchInput{
  margin-left:auto !important;
}


/* ===============================
   Hamburger Menu – Visual Cleanup
   =============================== */
.hamburger-menu{
  box-sizing: border-box;
  padding: 12px;
}
.hamburger-menu button,
.hamburger-menu label{
  box-sizing: border-box;
  width: 100%;
  max-width: 100%;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  padding: 10px 12px;
  margin: 6px 0;
  font-size: 13px;
  font-weight: 600;
  line-height: 1.2;
  border-radius: 10px;
  white-space: normal;
  text-align: left;
}
.hamburger-menu button span,
.hamburger-menu label span{
  overflow-wrap: anywhere;
}
.hamburger-menu button:hover,
.hamburger-menu label:hover{
  background: rgba(255,255,255,.14);
}
/* ===============================
   Premium Person Card
   =============================== */
#personModal{animation:fadeIn .18s ease}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}

#personCard{
  border-radius:20px !important;
  padding:18px !important;
}
#personCard::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:20px;
  pointer-events:none;
  background: radial-gradient(600px 220px at 30% 0%, rgba(56,189,248,.20), transparent 60%),
              radial-gradient(520px 220px at 80% 10%, rgba(245,158,11,.16), transparent 60%);
  opacity:.9;
}
#personCard .pc-wrap{
  position:relative;
  display:flex;
  gap:14px;
  align-items:flex-start;
}
#personCard .pc-left{
  width:160px;
  flex:0 0 auto;
}
#personCard .pc-avatar{
  width:160px;
  height:160px;
  border-radius:22px;
  overflow:hidden;
  border-color:rgba(255,255,255,.16);
  box-shadow:0 20px 45px rgba(0,0,0,.45);
  background:rgba(255,255,255,.06);
  display:grid;
  place-items:center;
}
#personCard .pc-avatar img{width:100%;height:100%;object-fit:cover;display:block}
#personCard .pc-initials{
  font-weight:900;
  font-size:28px;
  letter-spacing:.5px;
  color:rgba(255,255,255,.9);
}
#personCard .pc-right{
  flex:1;
  min-width:0;
  padding-top:28px; /* reserve space for close button */
}
#pcName{
  text-align:left !important;
  font-weight:900 !important;
  font-size:18px !important;
  line-height:1.1;
  margin:2px 0 6px 0;
}
#pcTitle{
  text-align:left !important;
  opacity:.85 !important;
  margin:0 0 10px 0 !important;
  font-size:13px !important;
}
.pc-badges{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-bottom:12px;
}
.pc-chip{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  font-size:11px;
  letter-spacing:.3px;
  opacity:.95;
  max-width:100%;
}
.pc-chip strong{font-weight:800}
.pc-actions{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-top:10px;
}
.pc-action{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  color:#fff;
  text-decoration:none;
  font-size:12px;
  font-weight:700;
}
.pc-action:hover{background:rgba(255,255,255,.10)}
.pc-action .muted{opacity:.8;font-weight:700}
.pc-grid{
  margin-top:14px;
  display:grid;
  grid-template-columns:1fr;
  gap:8px;
}
.pc-row{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:10px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(10,16,30,.35);
}
.pc-row .k{
  font-size:11px;
  letter-spacing:1px;
  text-transform:uppercase;
  opacity:.6;
  white-space:nowrap;
}
.pc-row .v{
  font-size:12px;
  font-weight:700;
  opacity:.92;
  text-align:right;
  word-break:break-word;
}
#pcViewDept{
  width:100%;
  margin:12px 0 0 0 !important;
  padding:10px 12px !important;
  border-radius:14px !important;
  font-weight:800 !important;
  letter-spacing:.4px;
  background:rgba(56,189,248,.18) !important;
  border:1px solid rgba(56,189,248,.35) !important;
}
#pcViewDept:hover{background:rgba(56,189,248,.24) !important}


/* --- Header control height + no-fill cleanup --- */
header button,
header .hamburger button,
header label{
  height:44px;
  min-height:44px;
  padding:0 14px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  background:transparent !important;
}

#hamburgerBtn{
  background:transparent !important;
}

/* Top-right action buttons (to the right of search): show real background fill + lighten on hover (NO lift) */
header button.topaction{
  background-color: rgba(255,255,255,.08) !important;
  transform:none !important;
}
header button.topaction:hover{
  background-color: rgba(255,255,255,.18) !important;
  transform:none !important;
}
header button.topaction:active{
  background-color: rgba(255,255,255,.14) !important;
  transform:none !important;
}


/* Top-right action buttons: match Search placeholder color */
header button.topaction{ color: rgba(247,250,252,.6) !important; }
/* Ensure the </> hamburger button also fills + lightens */
#hamburgerBtn{
  background-color: rgba(255,255,255,.08) !important;
}
#hamburgerBtn:hover{
  background-color: rgba(255,255,255,.18) !important;
}
#hamburgerBtn:active{
  background-color: rgba(255,255,255,.14) !important;
}

/* Remove fill but keep outline */
header button,
header label{
  border:1px solid rgba(255,255,255,.35);
}

/* Match search bar radius exactly */
header button,
header label,
#searchInput{
  border-radius:10px;
}


/* --- Header title typography to match department labels --- */
.header-title{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  font-weight: 700;
  letter-spacing: .8px;
  text-transform: uppercase;
  color: rgba(56,189,248,.9);
  text-shadow: 0 1px 2px rgba(0,0,0,.45);
}


/* --- Header title: match DEPT typography (condensed) + 60% opacity color --- */
.header-title{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  font-weight: 700;
  font-stretch: condensed;
  letter-spacing: .8px;
  text-transform: uppercase;
  color: rgba(247,250,252,.6); /* 60% opacity of original header text color */
  text-shadow: 0 1px 2px rgba(0,0,0,.45);
}


/* --- Header title: Roboto Flex Thin --- */
.header-title{
  font-family: 'Roboto Flex', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
  font-weight: 100;
  font-stretch: condensed;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: rgba(247,250,252,.6);
  text-shadow: 0 1px 2px rgba(0,0,0,.45);
}


/* --- Lower left logo slightly --- */
#homeLogo{
  margin-top:20px;
  /* Make the logo monochrome + subtle so it matches header/button text */
  opacity: .6;
  filter: brightness(0) saturate(100%) invert(1);
}


/* ===============================
   Global Typography: Roboto Flex
   =============================== */

/* Base font */
body{
  font-family: 'Roboto Flex', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
  font-weight: 400;
}

/* Header title (thin, airy) */
.header-title{
  font-weight: 100;
  font-stretch: condensed;
}

/* Department labels (narrow, strong) */
.dept{
  font-weight: 700;
  font-stretch: condensed;
  letter-spacing: .7px;
}

/* Names */
.name{
  font-weight: 600;
}

/* Titles / subtitles */
.title{
  font-weight: 400;
}

/* Buttons / UI controls */
button,
label{
  font-weight: 600;
}

/* Search input text */
#searchInput{
  font-weight: 400;
}

/* Person card */
#pcName{
  font-weight: 700;
}
#pcTitle{
  font-weight: 400;
}
.pc-chip strong{
  font-weight: 700;
}
.pc-row .k{
  font-weight: 600;
}
.pc-row .v{
  font-weight: 500;
}


/* --- Names: bump to bold --- */
.name{
  font-weight: 700;
}


/* ===============================
   Kerning + weight corrections
   =============================== */

/* Loosen overall tracking slightly */
body{
  letter-spacing: .15px;
}

/* Explicit weights to avoid inheritance conflicts */
.name{
  font-weight: 700 !important;
  letter-spacing: .25px;
}

.title{
  letter-spacing: .2px;
}

.dept{
  letter-spacing: .9px;
}

.header-title{
  letter-spacing: 1.6px;
}

/* UI controls slightly looser */
button,
label,
#searchInput{
  letter-spacing: .3px;
}


/* ===============================
   GLOBAL FONT OVERRIDE: Plus Jakarta Sans
   =============================== */
body,
button,
label,
input,
.header-title,
.name,
.title,
.dept,
.pc-row,
.pc-chip,
.pc-action,
#pcName,
#pcTitle {
  font-family: 'Plus Jakarta Sans', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif !important;
}

/* Hierarchy */
.header-title { font-weight: 300; letter-spacing: 1.4px; }
.dept { font-weight: 700; letter-spacing: .9px; }
.name { font-weight: 700; letter-spacing: .25px; }
.title { font-weight: 400; letter-spacing: .2px; }
button, label { font-weight: 600; }
#pcName { font-weight: 700; }
#pcTitle { font-weight: 400; }


/* ===============================
   Noise Reduction #1:
   Hide title + department by default
   =============================== */

/* Default: show NAME only */
.node .title,
.node .dept{
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  transition: opacity .15s ease, max-height .15s ease;
}

/* Reveal on hover, selection, or focus */
.node:hover .title,
.node:hover .dept,
.node.selected .title,
.node.selected .dept{
  opacity: 1;
  max-height: 40px;
}


/* ===============================
   Noise Reduction #2:
   Stronger fade for non-active branches
   =============================== */

/* Base visibility */
.node{
  transition: opacity .2s ease;
}

/* When a leader is selected, fade everything */
.node.fade-out{
  opacity: 0.15;
}

/* Always keep root and selected nodes fully visible */
.node.root,
.node.selected{
  opacity: 1 !important;
}


/* ===============================
   Noise Reduction #4:
   Zoom-based detail reveal
   =============================== */

/* Default: circles only */
.zoom-low .label{ opacity:0; pointer-events:none; }

/* Medium zoom: show names */
.zoom-mid .name{ opacity:1; }
.zoom-mid .title,
.zoom-mid .dept{ opacity:0; max-height:0; }

/* High zoom: show name + title */
.zoom-high .name,
.zoom-high .title{ opacity:1; max-height:40px; }
.zoom-high .dept{ opacity:0; }

/* Very high zoom: show all */
.zoom-full .label *{ opacity:1; max-height:none; }


/* ===============================
   Emphasize Susan Bourgeois photo
   =============================== */
.node[data-name="Susan Bourgeois"] .photo,
.node.root .photo{
  transform: scale(1.4);
  transform-origin: center;
}


/* ===============================
   Hamburger button alignment + border
   =============================== */

/* Match border style with other header buttons */
#hamburgerBtn{
  border: 1px solid rgba(255,255,255,.35);
  background: transparent;
  padding: 0;
}

/* Center the bars perfectly */
#hamburgerBtn span,
#hamburgerBtn div{
  display: flex;
  align-items: center;
  justify-content: center;
}

/* If using pseudo-bars */
#hamburgerBtn::before,
#hamburgerBtn::after{
  left: 50%;
  transform: translateX(-50%);
}


/* ===============================
   Hamburger button: hard center fix
   =============================== */

#hamburgerBtn{
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

/* Inner icon wrapper */
#hamburgerBtn > *{
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 4px;
}

/* Bars themselves */
#hamburgerBtn span,
#hamburgerBtn .bar{
  margin: 0;
}


/* ===============================
   Hamburger: pixel-perfect centering
   =============================== */

/* Force same height as other header buttons */
#hamburgerBtn{
  height: 44px;
  width: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}

/* Absolutely center the icon stack */
#hamburgerBtn .hamburger,
#hamburgerBtn .icon,
#hamburgerBtn svg,
#hamburgerBtn > div{
  position: relative;
  top: 1px; /* optical adjustment */
}

/* Normalize bar spacing */
#hamburgerBtn span,
#hamburgerBtn .bar{
  display: block;
  height: 2px;
  margin: 3px 0;
}


/* ===============================
   Hamburger icon font-metric fix
   =============================== */

/* If hamburger is a text glyph (☰), kill font padding */
#hamburgerBtn{
  line-height: 0;
}

/* Directly target the glyph */
#hamburgerBtn::before,
#hamburgerBtn span,
#hamburgerBtn .hamburger,
#hamburgerBtn .icon{
  line-height: 1;
}

/* Final optical correction */
#hamburgerBtn > *{
  transform: translateY(2px);
}


/* ===============================
   Hamburger icon: SVG (no font metrics)
   =============================== */
#hamburgerBtn{
  width:44px;
  height:44px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  line-height:0; /* ensure no font ascent affects layout */
}

#hamburgerBtn svg{
  width:22px;
  height:22px;
  display:block;
}

#hamburgerBtn svg rect{
  fill: rgba(255,255,255,.9);
}


/* ===============================
   FINAL: Remove legacy hamburger offsets
   =============================== */
#hamburgerBtn .hamburger,
#hamburgerBtn .icon,
#hamburgerBtn svg,
#hamburgerBtn > div{
  position: static !important;
  top: auto !important;
  transform: none !important;
}

#hamburgerBtn > *{
  transform: none !important;
}

#hamburgerBtn{
  align-items: center !important;
  justify-content: center !important;
}

#hamburgerBtn svg{
  transform: none !important;
  margin: 0 !important;
}


/* ===============================
   Zoom text behavior (CSS-only, safe)
   =============================== */

/* Default (initial load and above): all text visible */
.node .name,
.node .title,
.node .dept{
  opacity: 1;
  max-height: 40px;
  transition: opacity .15s ease;
}

/* Low zoom: department only */
.zoom-low .node .name,
.zoom-low .node .title{
  opacity: 0;
  max-height: 0;
}

.zoom-low .node .dept{
  opacity: 1;
  max-height: 30px;
}

/* Very zoomed out: hide all text */
.zoom-low.zoom-far .node .name,
.zoom-low.zoom-far .node .title,
.zoom-low.zoom-far .node .dept{
  opacity: 0;
  max-height: 0;
}


/* ===============================
   Zoom-low behavior: dept only (hover reveals all)
   =============================== */

/* At zoom-low: hide name + title */
.zoom-low .node .name,
.zoom-low .node .title{
  opacity: 0;
  max-height: 0;
  pointer-events: none;
}

/* At zoom-low: show department */
.zoom-low .node .dept{
  opacity: 1;
  max-height: 30px;
}

/* Hover overrides at zoom-low */
.zoom-low .node:hover .name,
.zoom-low .node:hover .title{
  opacity: 1;
  max-height: 40px;
  pointer-events: auto;
}


/* ===============================
   Zoom-low: department ONLY (no hover reveal)
   =============================== */

/* At zoom-low: hide name + title completely */
.zoom-low .node .name,
.zoom-low .node .title{
  opacity: 0;
  max-height: 0;
  pointer-events: none;
}

/* At zoom-low: show department */
.zoom-low .node .dept{
  opacity: 1;
  max-height: 30px;
}


/* ===============================
   FINAL OVERRIDE: zoom-low = dept only, hover reveals all
   =============================== */

/* Default at zoom-low: dept only */
.zoom-low .node .name,
.zoom-low .node .title{
  opacity: 0 !important;
  max-height: 0 !important;
  pointer-events: none !important;
}

.zoom-low .node .dept{
  opacity: 1 !important;
  max-height: 30px !important;
}

/* Hover at zoom-low: reveal name + title (dept stays visible) */
.zoom-low .node:hover .name,
.zoom-low .node:hover .title{
  opacity: 1 !important;
  max-height: 40px !important;
  pointer-events: none !important; /* labels are non-interactive anyway */
}


/* ===============================
   Text refinements: dept + title wrapping
   =============================== */

/* Smaller department titles */
.node .dept{
  font-size: 8px;
  line-height: 1.1;
  letter-spacing: .6px;
}

/* Better title line breaks (no mid-word breaks) */
.node .title{
  max-width: 140px;
  white-space: normal;
  word-break: normal;
  overflow-wrap: break-word;
  hyphens: none;
  line-height: 1.25;
}

/* Slightly smaller names for balance */
.node .name{
  font-size: 11.5px;
  line-height: 1.2;
}


/* ===============================
   Emphasize Susan Bourgeois photo
   =============================== */
.node[data-name="Susan Bourgeois"] .photo,
.node.root .photo{
  transform: scale(1.35);
  transform-origin: center;
}


/* ===============================
   Susan Bourgeois fixed size (90px)
   =============================== */
.node[data-name="Susan Bourgeois"] .photo,
.node[data-name="Susan Bourgeois"] .circle,
.node.root .photo,


/* ===============================
   Zoom-out behavior: department only
   =============================== */

/* Default (normal zoom): show all text */
.node .name,
.node .title,
.node .dept{
  opacity: 1;
  max-height: 40px;
}

/* Zoomed out: department title only */
.zoom-low .node .name,
.zoom-low .node .title{
  opacity: 0;
  max-height: 0;
}

.zoom-low .node .dept{
  opacity: 1;
  max-height: 30px;
}


/* ===============================
   FIX: zoom-low was hiding the entire label
   (Noise Reduction #4 sets .zoom-low .label { opacity:0 })
   We override so department remains visible.
   =============================== */

.zoom-low .label{
  opacity: 1 !important;
  pointer-events: none !important;
}

/* zoom-low: department ONLY */
.zoom-low .name,
.zoom-low .title{
  opacity: 0 !important;
  max-height: 0 !important;
}

.zoom-low .dept{
  opacity: 1 !important;
  max-height: 30px !important;
}


/* ===============================
   Connector line stroke width (starburst + traditional)
   =============================== */
#svg #lines line,
#svg #lines path,
#svg #lines polyline{
  stroke-width: 1.3 !important;
}


/* ===============================
   Widen label boxes by +40px
   =============================== */
.node .label{
  padding-right: calc(40px + 0px); /* add 40px effective width */
}


/* ===============================
   Dept label width tuning (less aggressive wrap)
   =============================== */

/* Give department titles more horizontal room */
.node .dept{
  max-width: 180px;   /* was tighter before */
  white-space: normal;
}


/* ===============================
   Dept label width tuning (200px)
   =============================== */
.node .dept{
  max-width: 200px;
}


/* ===============================
   Dept titles: force break after ampersand
   =============================== */
.node .dept{
  max-width: 260px;
}

/* Force & to end the line cleanly */
.node .dept{
  word-spacing: 0.1em;
}
.node .dept::after{
  content: "";
}


/* ===============================
   Larger clickable hit area for card close (X)
   =============================== */

/* Assume .card-close or .close-btn is the X element */
.card-close,
.close-btn,
.card .close {
  position: absolute;
}

/* Invisible hit target overlay */
.card-close::before,
.close-btn::before,
.card .close::before {
  content: "";
  position: absolute;
  top: -12px;
  right: -12px;
  bottom: -12px;
  left: -12px;
  cursor: pointer;
}


/* --- Person card close button hard safety --- */
#personClose{ pointer-events:auto !important; }
#personClose svg{ pointer-events:none; }
#personCard{ overflow: visible; }


/* ===============================
   Department Focus Mode (Step 2)
   =============================== */
body.dept-focus .node{
  opacity: 0.1;
  filter: blur(5px) saturate(0.9);
  transition:opacity .25s ease, filter .25s ease;
  /* Ensure interactive (focused) nodes are always on top when things overlap */
  z-index: 1;
}
body.dept-focus .node.focused{ z-index: 40; }
body.dept-focus .node.root{ z-index: 45; }
body.dept-focus .node.focused{
  opacity:1 !important;
  filter:none !important;
}

/* In dept-focus, only focused nodes should be interactive.
   This prevents background (blurred) nodes from "stealing" clicks/drags under overlapping focused nodes. */
body.dept-focus .node:not(.focused):not(.root),
body.dept-focus .node:not(.focused):not(.root) *{
  pointer-events:none !important;
}
body.dept-focus .node.focused,
body.dept-focus .node.root{
  pointer-events:auto;
}

/* During an active drag, disable pointer events on other nodes to avoid accidental grabs. */
body.is-dragging .node:not(.dragging){
  pointer-events:none;
}
body.is-dragging .node.dragging{
  pointer-events:auto;
}


/* Ensure deemphasis overrides dept-focus focused styling */
body.dept-focus .node.focused.deemph{
  opacity: 0.1 !important;
  filter: blur(5px) saturate(0.9) !important;
}

/* In dept-focus, deemphasized nodes are treated as background (non-interactive). */
body.dept-focus .node.deemph:not(.root),
body.dept-focus .node.deemph:not(.root) *{
  pointer-events:none !important;
}


body.dept-focus .node.focused{
  filter:none !important;
}

/* Staff circles read sharper at small sizes; match blur strength with other deemphasized nodes */
body.dept-focus .node.staff:not(.focused),
body.dept-focus .node.staff.deemph{
  filter: blur(5px) saturate(0.9) !important;
}


/* --- Root always stays in focus --- */
body.dept-focus .node.root{
  opacity:1 !important;
  filter:none !important;
}


/* ===============================
   Dept Focus – Line De-emphasis
   =============================== */

/* Default line behavior */
.line{
  transition: opacity .25s ease, filter .25s ease;
}

/* Fade + blur ALL lines when in dept focus */
body.dept-focus .line{
  opacity:0.075;
  stroke-opacity:0.075;
  filter:blur(2px);
}

/* Keep active branch lines crisp */
body.dept-focus .line.focused-line{
  opacity:1 !important;
  stroke-opacity:1 !important;
  filter:none !important;
}


/* --- Focused lines must always stay fully visible --- */
body.dept-focus .line.focused-line{
  opacity:1 !important;
  stroke-opacity:1 !important;
  filter:none !important;
}


/* Solid node backdrop to block SVG bleed */
.node::before{
  content:"";
  position:absolute;
  inset:-4px;
  background:rgba(10,20,35,0.4);
  border-radius:50%;
  z-index:-1;
}


/* Strong fade ONLY for non-focused nodes */
body.dept-focus .node:not(.focused)::before{
  background:rgba(10,20,35,0.98);
}


/* Disable legacy View Department feature */
#pcViewDept{
  display:none !important;
}


/* Hide legacy Reset Layout button safely */
#resetLayout,
.reset-layout,
button[aria-label="Reset Layout"]{
  display:none !important;
}


/* HARD remove Reset Layout header button */
#resetLayoutBtn{
  display:none !important;
}


/* --- Hamburger icon as </> --- */
#hamburgerBtn{
  font-family: 'Plus Jakarta Sans', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif !important;
  font-weight: 800;
  font-size: 16px;
  letter-spacing: 0.5px;
}


/* --- Remove Export Dept Layout from menu --- */
#exportDeptLayoutBtn{ display:none !important; }


/* --- Center text in hamburger menu buttons --- */
.hamburger-menu button{
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
}


/* --- Center text in hamburger menu labels too (Upload / Load JSON) --- */
.hamburger-menu label{
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  text-align:center !important;
}






/* === Curved Dept Halo Label === */

/* --- Header Search: match button hover polish + small all-caps typography --- */
#searchInput{
  font-size: 11px !important;
  text-transform: uppercase;
  letter-spacing: 1.4px;
  font-weight: 600;
  transition:
    background-color 140ms ease,
    border-color 140ms ease,
    box-shadow 140ms ease,
    filter 140ms ease;
}

#searchInput::placeholder{
  text-transform: uppercase;
  letter-spacing: 1.2px;
  color: rgba(247,250,252,.55) !important;
}

#searchInput:hover{
  background: rgba(255,255,255,.12) !important;
  border-color: rgba(255,255,255,.26) !important;
  box-shadow: 0 10px 22px rgba(0,0,0,.22);
}

#searchInput:focus{
  background: rgba(255,255,255,.10) !important;
  border-color: rgba(96,165,250,.65) !important;
  box-shadow:
    0 0 0 3px rgba(96,165,250,.35),
    0 10px 22px rgba(0,0,0,.22);
}


/* Option G: Hover-only expand hint */
.expand-hint{
  position:absolute;
  top:-34px;
  left:50%;
  transform: translateX(-50%) translateY(6px);
  opacity:0;
  pointer-events:none;
  background: rgba(0,0,0,0.72);
  color:#fff;
  padding:6px 8px;
  border-radius:999px;
  font-size: 8px;
  font-weight:700;
  white-space:nowrap;
  box-shadow:0 10px 18px rgba(0,0,0,0.22);
  transition: opacity 120ms ease, transform 120ms ease;
  z-index:20;
}
.expand-hint::after{
  content:"";
  position:absolute;
  left:50%;
  bottom:-6px;
  transform: translateX(-50%);
  width:0;
  height:0;
  border-left:6px solid transparent;
  border-right:6px solid transparent;
  border-top:6px solid rgba(0,0,0,0.72);
}
.node.expandable .circle:hover + .expand-hint{
  opacity:1;
  transform: translateX(-50%) translateY(0);
}




/* Clickability color cue + role sizing */
.circle{
  border-color: rgba(156,163,175,0.65); /* gray for non-expandable */
  border-width: 4px;
}

/* Role sizing */
.node.staff .circle{
  width:var(--size-staff);
  height:var(--size-staff);
}
.node.subleader .circle{
  width:var(--size-subleader);
  height:var(--size-subleader);
}
.node.leader .circle{
  width:var(--size-leader);
  height:var(--size-leader);
}
.node.root .circle{
  width:var(--size-root);
  height:var(--size-root);
}

/* Green ring for anything expandable */
.node.expandable .circle{
  border-color: rgba(56,189,248,0.95); /* teal */
  border-width: 6px;
}

/* Susan should be green too */
.node.root .circle{
  border-color: rgba(56,189,248,0.95);
  border-width: 6px;
}




/* De-emphasize other subleaders when one is selected */
.node.subleader.deemph{
  opacity: 0.1;
  filter: blur(1.4px) saturate(0.9);
  transition: opacity .25s ease, filter .25s ease;
}
.node.subleader.deemph .circle,
.node.subleader.deemph .label{
  filter: blur(2px);
}


body.is-dragging .tooltip{ display:none !important; }
body.is-dragging{ cursor: grabbing; }

/* ===============================
   USER REQUEST (2026-01-27):
   Keep ALL label text visible at all zoom levels.
   (No zoom-based hiding; text naturally scales with the viewport.)
   =============================== */
#viewport.zoom-low .label,
#viewport.zoom-mid .label,
#viewport.zoom-high .label,
#viewport.zoom-full .label{
  opacity: 1 !important;
  pointer-events: auto !important;
}

#viewport.zoom-low .node .name,
#viewport.zoom-low .node .title,
#viewport.zoom-low .node .dept,
#viewport.zoom-mid .node .name,
#viewport.zoom-mid .node .title,
#viewport.zoom-mid .node .dept,
#viewport.zoom-high .node .name,
#viewport.zoom-high .node .title,
#viewport.zoom-high .node .dept,
#viewport.zoom-full .node .name,
#viewport.zoom-full .node .title,
#viewport.zoom-full .node .dept{
  opacity: 1 !important;
  max-height: 80px !important;
}

/* Disable any "zoom-far hide all text" rule */
#viewport.zoom-low.zoom-far .node .name,
#viewport.zoom-low.zoom-far .node .title,
#viewport.zoom-low.zoom-far .node .dept{
  opacity: 1 !important;
  max-height: 80px !important;
}



/* =======================
   Mobile portrait mode
   - Navigation-first
   - Force Traditional
   - Simplify header chrome
   ======================= */
@media (max-width: 600px) and (orientation: portrait){
  /* Mobile portrait = navigation-first */
  body.mobile-portrait header{
    height:auto;
    padding:8px 10px;
    gap:8px;
    flex-wrap:wrap;
    align-items:center;
  }

  body.mobile-portrait #homeLogo{
    height:40px;
    margin-right:8px;
  }

  /* Keep logo + search on the first row */
  body.mobile-portrait .spacer{ display:none !important; }

  body.mobile-portrait #searchInput{
    min-width:0 !important;
    max-width:none !important;
    width:auto !important;
    flex:1 1 auto;
    height:40px !important;
  }

  /* Move the title to its own centered line, slightly larger */
  body.mobile-portrait .header-title{
    flex:1 0 100%;
    order:99;
    text-align:center;
    font-size:14px;
    letter-spacing:.10em;
    text-transform:uppercase;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    max-width:none;
    margin-top:4px;
  }

  /* Hide all header controls except logo/title/search */
  body.mobile-portrait header > label,
  body.mobile-portrait header > button,
  body.mobile-portrait header > strong,
  body.mobile-portrait header > span{
    display:none !important;
  }

  /* Hide the </> menu button in mobile portrait */
  body.mobile-portrait .hamburger,
  body.mobile-portrait #hamburgerBtn{
    display:none !important;
  }

  /* Make picker span the screen */
  body.mobile-portrait #searchResults{
    width:calc(100vw - 24px) !important;
    left:12px !important;
  }
}

/* ===============================
   Mobile Drilldown Mode (portrait-first)
   =============================== */
body.mobile-mode{ overflow:hidden; }
body.mobile-mode header,
body.mobile-mode main,
body.mobile-mode #searchOverlay{ display:none !important; }

#mobileApp{
  position:fixed;
  inset:0;
  z-index:9000;
  display:none;
  flex-direction:column;
  background:
    radial-gradient(900px 600px at 15% 15%,rgba(96,165,250,.18),transparent 60%),
    radial-gradient(900px 600px at 85% 20%,rgba(56,189,248,.45),transparent 60%),
    radial-gradient(900px 600px at 65% 85%,rgba(245,158,11,.14),transparent 55%),
    linear-gradient(180deg,#0b1d36,#071427);
  color:#f7fafc;
  overflow:hidden;
}

body.mobile-mode #mobileApp{ display:flex; }

#mobileTop{
  position:sticky;
  top:0;
  z-index:5;
  padding:10px 12px 12px;
  background:rgba(10,16,30,.78);
  border-bottom:1px solid rgba(255,255,255,.14);
  backdrop-filter:blur(12px);
}

#mobileTop .m-row{
  display:flex;
  align-items:center;
  gap:10px;
}

#mobileTop .m-title{
  font-weight:900;
  letter-spacing:.6px;
  text-transform:uppercase;
  font-size:13px;
  line-height:1.1;
  opacity:.95;
  flex:1;
  min-width:0;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

#mobileTop .m-btn{
  height:38px;
  padding:0 10px;
  border-radius:12px;
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.16);
  color:#fff;
  font-weight:800;
  font-size:11px;
  letter-spacing:1.1px;
  text-transform:uppercase;
  cursor:pointer;
}

#mobileSearch{
  margin-top:10px;
  width:100%;
  height:44px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.18);
  background:rgba(255,255,255,.08);
  color:#fff;
  padding:0 12px;
  outline:none;
  font-size:14px;
}

#mobileSearch::placeholder{ color:rgba(247,250,252,.62); }

#mobileSearchResults{
  margin-top:10px;
  display:none;
  max-height:40vh;
  overflow:auto;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(10,16,30,.65);
}

#mobileSearchResults.open{ display:block; }

.m-sr-item{
  padding:10px 12px;
  border-top:1px solid rgba(255,255,255,.08);
  cursor:pointer;
}
.m-sr-item:first-child{ border-top:none; }
.m-sr-item:hover{ background:rgba(96,165,250,.14); }
.m-sr-item .name{ font-weight:900; font-size:13px; }
.m-sr-item .meta{ opacity:.72; font-size:12px; margin-top:2px; }

#mobileCrumb{
  margin-top:10px;
  display:flex;
  align-items:center;
  gap:10px;
}

#mobileBack{
  display:none;
  height:36px;
  padding:0 12px;
  border-radius:12px;
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.16);
  color:#fff;
  font-weight:900;
  letter-spacing:1.1px;
  text-transform:uppercase;
  font-size:11px;
  cursor:pointer;
}

#mobilePath{
  flex:1;
  min-width:0;
  opacity:.85;
  font-size:12px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

#mobileBody{
  flex:1;
  overflow:auto;
  padding:12px;
}

#mCard{
  border-radius:18px;
  border:1px solid rgba(255,255,255,.14);
  background:linear-gradient(180deg,#0f172a,#0b1220);
  box-shadow:0 18px 50px rgba(0,0,0,.45);
  padding:14px;
}

#mCardTop{
  display:flex;
  gap:12px;
  align-items:center;
}

.m-avatar{
  width:64px;height:64px;border-radius:50%;
  overflow:hidden;
  background:#0b1220;
  border:6px solid rgba(56,189,248,.85);
  box-shadow:0 10px 22px rgba(0,0,0,.35), 0 0 0 2px rgba(255,255,255,.10);
  display:grid;
  place-items:center;
  flex:0 0 auto;
}
.m-avatar img{ width:100%; height:100%; object-fit:cover; display:block; }
.m-avatar .ini{ font-weight:900; letter-spacing:.6px; }

#mCardName{ font-weight:950; font-size:16px; line-height:1.1; }
#mCardTitle{ opacity:.78; font-size:13px; margin-top:3px; line-height:1.2; }

#mCardBadges{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-top:10px;
}
.m-chip{
  border-radius:999px;
  padding:6px 10px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  font-size:11px;
  opacity:.9;
}
.m-chip strong{ font-weight:950; margin-right:6px; opacity:.9; }

#mCardActions{
  display:flex;
  gap:10px;
  margin-top:12px;
}
.m-action{
  flex:1;
  height:40px;
  border-radius:14px;
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.16);
  color:#fff;
  font-weight:950;
  letter-spacing:1.0px;
  text-transform:uppercase;
  font-size:11px;
  cursor:pointer;
}

#mobileSectionTitle{
  margin:14px 2px 8px;
  font-weight:950;
  font-size:12px;
  letter-spacing:1.1px;
  text-transform:uppercase;
  opacity:.86;
}

#mobileReports{
  display:flex;
  flex-direction:column;
  gap:10px;
  padding-bottom:24px;
}

.m-report{
  display:flex;
  gap:10px;
  align-items:center;
  padding:10px 12px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.06);
  cursor:pointer;
}

.m-report:hover{ background:rgba(255,255,255,.08); }

.m-report .ra{
  width:44px;height:44px;border-radius:50%;
  overflow:hidden;
  background:#0b1220;
  border:6px solid rgba(56,189,248,.70);
  display:grid;
  place-items:center;
  flex:0 0 auto;
}
.m-report .ra img{ width:100%; height:100%; object-fit:cover; display:block; }
.m-report .ra .ini{ font-weight:950; font-size:13px; }

.m-report .txt{ flex:1; min-width:0; }
.m-report .txt .n{ font-weight:950; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.m-report .txt .t{ opacity:.72; font-size:12px; margin-top:2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.m-report .chev{ opacity:.75; font-weight:950; }

</style>




<style>
/* --- Card visual refresh --- */
.dept-chip span{
  color: rgb(56,189,248);
  font-weight: 800;
  letter-spacing: 1px;
  text-transform: uppercase;
}
#personCard{
  backdrop-filter: blur(14px);
}
#pcName{
  font-size: 22px !important;
}
#pcTitle{
  font-size: 14px !important;
}

/* --- Hamburger icon as </> --- */
#hamburgerBtn{
  font-family: 'Plus Jakarta Sans', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif !important;
  font-weight: 800;
  font-size: 16px;
  letter-spacing: 0.5px;
}


/* --- Remove Export Dept Layout from menu --- */
#exportDeptLayoutBtn{ display:none !important; }


/* --- Center text in hamburger menu buttons --- */
.hamburger-menu button{
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
}


/* --- Center text in hamburger menu labels too (Upload / Load JSON) --- */
.hamburger-menu label{
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  text-align:center !important;
}




/* === Curved Dept Halo Label === */


/* --- Header title color (department name / OFFICE OF THE SECRETARY) --- */
header .header-title{ color: rgba(56,189,248,.95) !important; }
</style>


<script>
function autoLoadLayout(mode, opts){
  opts = opts || {};
  const preserveView = !!opts.preserveView;
  const anchorId = opts.anchorId || null;
  const anchorScreen = opts.anchorScreen || null;

  const file = mode === "traditional" ? "layout_traditional.json" : "layout_starburst.json";

  // Keep a specific anchor node at the same screen position after applying a new layout.
  function preserveAnchor(){
    if(!preserveView || !anchorId || !anchorScreen) return;
    const p = pos && pos.get ? pos.get(anchorId) : null;
    if(!p) return;
    const newSx = p.x * zoom + panX;
    const newSy = p.y * zoom + panY;
    panX += (anchorScreen.sx - newSx);
    panY += (anchorScreen.sy - newSy);
    applyTransform();
  }

  return fetch("./" + file, { cache: "no-store" })
    .then(r=>{ if(!r.ok) throw 0; return r.json(); })
    .then(layout=>{
      applyLayout(layout);
      render();
      exposeDebug();

      // If this per-mode layout JSON includes a saved viewport, use it as the home framing (initial load).
      try{
        if(!preserveView && layout && layout.viewport){
          const v = layout.viewport;
          const vz = Number(v.zoom), vx = Number(v.panX), vy = Number(v.panY);
          if(isFinite(vz) && isFinite(vx) && isFinite(vy)){
            zoom = vz; panX = vx; panY = vy;
            applyTransform();
            try{ snapshotHomeViewport(mode); }catch(_e){}
            return;
          }
        }
      }catch(_e){}


      // Seamless mode switches should NOT recenter the chart.
      if(preserveView){
        preserveAnchor();
        return;
      }

      // Default behavior (initial load): center on root and snapshot home viewport.
      requestAnimationFrame(()=>requestAnimationFrame(()=>{
        const yOff = (mode === 'starburst') ? 150 : 0;
        centerOnNodeBiased(rootPerson().id, 0.5, 0.28, yOff, true);
        setTimeout(()=>snapshotHomeViewport(mode), 340);
      }));
    })
    .catch(()=>{});
}



// Dept-focus hard isolation: block any background node interaction at capture phase
(function(){
  function blockBackgroundInteraction(e){
    if(!document.body.classList.contains("dept-focus")) return;
    const node = (e.target && e.target.closest) ? e.target.closest(".node") : null;
    if(!node) return;
    if(node.classList.contains("root")) return;
    if(node.classList.contains("focused") && !node.classList.contains("deemph")) return;
    e.preventDefault();
    e.stopPropagation();
    if(typeof e.stopImmediatePropagation === "function") e.stopImmediatePropagation();
  }
  document.addEventListener("pointerdown", blockBackgroundInteraction, true);
  document.addEventListener("click", blockBackgroundInteraction, true);
})();

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>

</head>

<body>


<div id="instructions" class="howto">
  <div id="instructionsToggle" class="howto-toggle" role="button" aria-expanded="false" tabindex="0">
    <span class="howto-icon" aria-hidden="true">!</span>
    <span class="howto-title">HOW TO USE</span>
  </div>
  <div id="instructionsBody" class="howto-body">
        <div>• Drag background to pan chart</div>
    <div>• Scroll/Pinch to zoom</div>
    <div>• Click photo to expand/collapse direct reports</div>
    <div>• Drag photo/label to reposition (Starburst layout)</div>
    <div>• Click the name/title to open info card</div>
    <div>• Use search to jump to a person/department</div>
  </div>
</div>


<header>
  
<img id="homeLogo" src="photos/LED_logoFULL_COLOR.svg" alt="Logo" style="height:56px;margin-right:14px;cursor:pointer;">
<div class="header-title">OFFICE OF THE SECRETARY</div>

<strong></strong>
  <span style="opacity:.7;font-size:12px"></span>
  <div class="spacer"></div>
<input id="searchInput" type="search" placeholder="Search people…"
  aria-label="Search people"
  style="
    height:44px;
    min-width:260px;
    max-width:420px;
    padding:0 12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.18);
    background:rgba(255,255,255,.08);
    color:#fff;
    outline:none;
  " autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="search">


  
  <label>Upload CSV/XLSX<input id="fileInput" type="file" accept=".csv,.xlsx,.xls"></label>
  <button id="authorModeBtn" title="Toggle WYSIWYG authoring (drag to arrange)">Author Mode: Off</button>
  <button id="saveDefaultLayoutBtn" disabled title="Save current positions as the default Reset Layout baseline">Save Starburst Layout</button>
  <button id="exportDeptLayoutBtn" disabled>Export Dept Layout</button>

  <button id="editConnectorsBtn" title="Traditional only: click a line to edit connectors">Edit Connectors: Off</button>
  <label id="loadLayoutLbl" title="Load a previously-saved layout.json">Load Layout JSON<input id="layoutInput" type="file" accept=".json"></label>
  <button id="clearDefaultLayoutBtn" title="Clear default layout and go back to starburst on Reset">Clear Default</button>
  
  
  <button id="layoutToggleBtn" title="Toggle Starburst / Traditional" class="topaction">View in Starburst</button>
  <button id="homeBtn" class="topaction">RESET</button>
  <button id="resetLayoutBtn">Reset Layout</button>

  <div class="hamburger">
    <button id="hamburgerBtn" aria-label="Menu" title="Menu" class="topaction">&lt;/&gt;</button>
    <div id="hamburgerMenu" class="hamburger-menu"></div>
  </div>

  <button id="isolateBtn" disabled style="display:none">Isolate Selected Dept</button>
  <button id="backBtn" style="display:none">Back to Full Org</button>
  <button id="resetBtn">Reset Data</button>
</header>

<div id="searchOverlay" aria-hidden="true"><div id="searchResults" role="listbox" aria-label="Search results"></div></div>


<div id="mobileApp" aria-hidden="true">
  <div id="mobileTop">
    <div class="m-row">
      <img id="mobileLogo" src="photos/LED_logoFULL_COLOR.svg" alt="Logo" style="height:30px;width:auto;">
      <div class="m-title">OFFICE OF THE SECRETARY</div>
      <button id="mobileDesktopBtn" class="m-btn" title="Switch to desktop canvas view">Desktop</button>
    </div>

    <input id="mobileSearch" type="search" placeholder="Search people…" aria-label="Search people"
      autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="search">

    <div id="mobileSearchResults" role="listbox" aria-label="Search results"></div>

    <div id="mobileCrumb">
      <button id="mobileBack" aria-label="Back">Back</button>
      <div id="mobilePath"></div>
    </div>
  </div>

  <div id="mobileBody">
    <div id="mCard">
      <div id="mCardTop">
        <div class="m-avatar" id="mAvatar">
          <div class="ini" id="mInitials">??</div>
          <img id="mPhoto" alt="" style="display:none;">
        </div>
        <div style="flex:1;min-width:0">
          <div id="mCardName"></div>
          <div id="mCardTitle"></div>
        </div>
      </div>

      <div id="mCardBadges"></div>

      <div id="mCardActions">
        <button id="mInfoBtn" class="m-action" title="Open info card">Info</button>
        <button id="mHomeBtn" class="m-action" title="Go to the top (root)">Home</button>
      </div>
    </div>

    <div id="mobileSectionTitle">Direct Reports</div>
    <div id="mobileReports"></div>
  </div>
</div>


<main>
<div id="stage">
  <div id="viewport">
  <svg id="svg" preserveAspectRatio="none">
    <g id="lines"></g>
  </svg>
  <svg id="handlesSvg" preserveAspectRatio="none" aria-hidden="true">
    <g id="lineHandles"></g>
  </svg>
  <div id="nodes"></div>
  </div>
</div>
</main>

<!-- Default layout (optional). Paste layout JSON between the tags to make it the authoritative Reset Layout baseline. -->
<script id="defaultLayoutJson" type="application/json">null</script>
<div id="toast"></div>


<script>
const svg = document.getElementById("svg");
const handlesSvg = document.getElementById("handlesSvg") || svg;
const linesG = document.getElementById("lines");
const nodesDiv = document.getElementById("nodes");
const fileInput = document.getElementById("fileInput");
const resetBtn = document.getElementById("resetBtn");

const lineHandlesG = document.getElementById("lineHandles");


// --- Traditional connector overrides (manual line routing) ---
window.TRAD_EDGE_OVERRIDES = window.TRAD_EDGE_OVERRIDES || {};
let TRAD_EDGE_OVERRIDES = window.TRAD_EDGE_OVERRIDES;
// Parent-level Traditional "bus/junction" overrides (one per parent, shared across its child branches)
window.TRAD_PARENT_OVERRIDES = window.TRAD_PARENT_OVERRIDES || {};
let TRAD_PARENT_OVERRIDES = window.TRAD_PARENT_OVERRIDES;

let LINE_EDIT_MODE = false;
let SELECTED_EDGE = null; // {from,to}
let __LINE_HANDLE_DRAG__ = null;

// Ensure the "Edit Connectors" button is always live (even if the hamburger/menu wiring changes)
function __bindEditConnectorsBtn__(){
  const b = document.getElementById("editConnectorsBtn");
  if(!b) return;
  // Never hard-disable; we gate functionality in the handler.
  b.disabled = false;
  b.classList.toggle("soft-disabled", false);

  if(b.dataset.boundLineEdit === "1") return;
  b.dataset.boundLineEdit = "1";

  b.addEventListener("click", (ev)=>{
    // If the button is inside the hamburger, don't let global click-to-close logic eat the click.
    try{ ev.stopPropagation(); }catch(_e){}

    LINE_EDIT_MODE = !LINE_EDIT_MODE;
    try{ document.body.classList.toggle("line-edit", LINE_EDIT_MODE); }catch(_e){}

    if(!LINE_EDIT_MODE){
      SELECTED_EDGE = null;
      try{ __clearLineHandles__(); }catch(_e){}
      try{ renderLinesOnly(); }catch(_e){}
      b.textContent = "Edit Connectors: Off";
      toast("Edit connectors off");
      return;
    }

    // On -> require Traditional+Author for actual editing
    const isTrad = !!(document.body && document.body.classList.contains("traditional-mode"))
      || ((window.LAYOUT_MODE||"starburst")==="traditional");
    const isAuth = (typeof AUTHOR_MODE !== "undefined" ? !!AUTHOR_MODE : !!window.AUTHOR_MODE);

    b.textContent = "Edit Connectors: On";

    if(!(isTrad && isAuth)){
      toast("Tip: switch to Traditional + Author Mode to edit connectors");
      return;
    }
    toast("Click a line to edit; drag endpoints + bend");
  }, {passive:true});
}

// Expose a tiny debug helper for the dev console
window.__DBG_EDIT_CONNECTORS__ = function(){
  const b = document.getElementById("editConnectorsBtn");
  return {
    exists: !!b,
    disabled: b ? b.disabled : null,
    text: b ? b.textContent : null,
    lineEditMode: typeof LINE_EDIT_MODE !== "undefined" ? LINE_EDIT_MODE : null,
    layoutMode: (typeof LAYOUT_MODE !== "undefined" ? LAYOUT_MODE : window.LAYOUT_MODE),
    authorMode: (typeof AUTHOR_MODE !== "undefined" ? AUTHOR_MODE : window.AUTHOR_MODE),
    inTraditionalClass: !!(document.body && document.body.classList.contains("traditional-mode")),
    inLineEditClass: !!(document.body && document.body.classList.contains("line-edit")),
    selectedEdge: (typeof SELECTED_EDGE !== "undefined" ? SELECTED_EDGE : null)
  };
};

try{
  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", __bindEditConnectorsBtn__, {once:true});
  }else{
    __bindEditConnectorsBtn__();
  }
}catch(_e){}


// Line editing interactions (Traditional-only)
(function(){
  if(!svg || !linesG) return;

  // Select a line to edit
  linesG.addEventListener("pointerdown", (ev)=>{
    const mode = (document.body && document.body.classList.contains("traditional-mode")) ? "traditional" : ((typeof LAYOUT_MODE !== "undefined" ? LAYOUT_MODE : null) || (window.LAYOUT_MODE || "starburst"));
    if(!(mode === "traditional" && LINE_EDIT_MODE)) return;

    const t = ev.target;
    if(!t || t.tagName !== "polyline" || !t.classList || !t.classList.contains("line")) return;

    ev.preventDefault();
    ev.stopPropagation();

    const fromId = t.getAttribute("data-from");
    const toId = t.getAttribute("data-to");
    if(!fromId || !toId) return;

    SELECTED_EDGE = { from: fromId, to: toId };

    const key = __edgeKey__(fromId, toId);
    if(!TRAD_EDGE_OVERRIDES[key]) TRAD_EDGE_OVERRIDES[key] = { fromSide:"auto", toSide:"auto" };
    window.TRAD_EDGE_OVERRIDES = TRAD_EDGE_OVERRIDES;

    // Ctrl/Cmd+click the selected line to add an extra bend (waypoint)
    if(ev.ctrlKey || ev.metaKey){
      const p = __svgPointFromEvent__(ev);
      const visible = getVisibleSet();
      const guides = __collectTraditionalGuides__(visible, null);
      const snapPx = 10;
      const x = __snapValue__(p.x, guides.xs, snapPx);
      const y = __snapValue__(p.y, guides.ys, snapPx);

      const ov = TRAD_EDGE_OVERRIDES[key];
      if(!Array.isArray(ov.waypoints)) ov.waypoints = [];
      ov.waypoints.push({x,y});
      __updateEdgeOverride__(key, { waypoints: ov.waypoints });

      renderLinesOnly();
      toast("Bend added (Shift+click bend to remove)");
      return;
    }

    renderLinesOnly();
    toast("Drag endpoints to choose sides; drag the white square (or blue bends) to shape; drag the yellow handle to move the shared bus");
  }, {passive:false});

  // Handle drag begin
  (handlesSvg||svg).addEventListener("pointerdown", (ev)=>{
    const mode = (document.body && document.body.classList.contains("traditional-mode")) ? "traditional" : ((typeof LAYOUT_MODE !== "undefined" ? LAYOUT_MODE : null) || (window.LAYOUT_MODE || "starburst"));
    if(!(mode === "traditional" && LINE_EDIT_MODE)) return;

    const t = ev.target;
    if(!t || !t.classList || !(t.classList.contains("line-handle") || t.classList.contains("line-handle-hit"))) return;

    ev.preventDefault();
    ev.stopPropagation();

    const handleType = t.dataset.handle;
    const fromId = t.dataset.from;
    const toId = t.dataset.to;
    if(!handleType || !fromId || !toId) return;

    // Shift+click a waypoint handle to delete it
    if(handleType === "wp" && ev.shiftKey){
      const idx = t.dataset.idx ? parseInt(t.dataset.idx,10) : null;
      if(idx !== null){
        const key = __edgeKey__(fromId, toId);
        const ov = (TRAD_EDGE_OVERRIDES && TRAD_EDGE_OVERRIDES[key]) ? TRAD_EDGE_OVERRIDES[key] : null;
        if(ov && Array.isArray(ov.waypoints) && idx >= 0 && idx < ov.waypoints.length){
          ov.waypoints.splice(idx,1);
          __updateEdgeOverride__(key, { waypoints: ov.waypoints });
          renderLinesOnly();
          toast("Bend removed");
        }
      }
      return;
    }

    __beginLineHandleDrag__(handleType, fromId, toId, ev, (t.dataset.idx ? parseInt(t.dataset.idx,10) : null));
  }, {passive:false});

  (handlesSvg||svg).addEventListener("pointermove", (ev)=>{
    if(!__LINE_HANDLE_DRAG__) return;
    ev.preventDefault();
    ev.stopPropagation();
    __moveLineHandle__(ev);
  }, {passive:false});

  (handlesSvg||svg).addEventListener("pointerup", (ev)=>{
    if(!__LINE_HANDLE_DRAG__) return;
    ev.preventDefault();
    ev.stopPropagation();
    __endLineHandleDrag__(ev);
  }, {passive:false});

  (handlesSvg||svg).addEventListener("pointercancel", (ev)=>{
    if(!__LINE_HANDLE_DRAG__) return;
    __endLineHandleDrag__(ev);
  });

  // Escape to exit line edit mode
  document.addEventListener("keydown", (e)=>{
    if(e.key !== "Escape") return;
    if(!LINE_EDIT_MODE) return;
    LINE_EDIT_MODE = false;
    SELECTED_EDGE = null;
    document.body.classList.remove("line-edit");
    __clearLineHandles__();
    renderLinesOnly();
    try{
      const b = document.getElementById("editConnectorsBtn");
      if(b) b.textContent = "Edit Connectors: Off";
    }catch(_e){}
    toast("Edit connectors off");
  });
})();

let DATA = demoData();
let SEARCH_INDEX = null; // immutable snapshot for site-wide search

// runtime
const pos = new Map();
const BASE_POS = new Map(); // immutable baseline starburst positions (for stable child-side placement)
const CHILDREN_ALL = new Map(); // full org children map (independent of visibility)           // id -> {x,y}


function exposeDebug(){
  try{
    window.DATA = DATA;
    window.pos = pos;
    window.relOffset = relOffset;
    window.BASE_POS = BASE_POS;
    window.CHILDREN_ALL = CHILDREN_ALL;
    window.expandedLeader = expandedLeader;
    window.expandedSubleaders = expandedSubleaders;
    window.selectedSubleader = selectedSubleader;
    window.selectedStaffManager = (typeof selectedStaffManager !== 'undefined') ? selectedStaffManager : null;
  }catch(e){}
}

const relOffset = new Map();     // child -> {dx,dy} relative to reportsTo
const children = new Map();      // parent -> [child]
let edges = [];                  // {from,to,kind}

const VIEW = { w: window.__STAGE_W__ || 1600, h: window.__STAGE_H__ || 900 };
const CENTER = { x: VIEW.w/2, y: VIEW.h/2 + 10 };

function demoData(){
  return [
    {id:"susan",name:"Susan Bourgeois",title:"Secretary",leader:false,reportsTo:null,photo:"photos/susan.jpg"},
    {id:"chris",name:"Christopher Hale",title:"CEO",leader:true,reportsTo:"susan",photo:"photos/chris.jpg"},
    {id:"jordan",name:"Jordan Kim",title:"VP Operations",leader:true,reportsTo:"susan",photo:"photos/jordan.jpg"},
    {id:"priya",name:"Priya Nair",title:"VP Finance",leader:true,reportsTo:"susan",photo:"photos/priya.jpg"},
    {id:"alex",name:"Alex Rivera",title:"VP Technology",leader:true,reportsTo:"susan",photo:"photos/alex.jpg"},
    {id:"cameron",name:"Cameron Price",title:"VP Sales",leader:true,reportsTo:"susan",photo:"photos/cameron.jpg"},

    {id:"taylor",name:"Taylor Ellis",title:"Facilities Manager",leader:false,reportsTo:"jordan",photo:"photos/taylor.jpg"},
    {id:"parker",name:"Parker Diaz",title:"Logistics Manager",leader:false,reportsTo:"jordan",photo:"photos/parker.jpg"},
    {id:"finley",name:"Finley Carter",title:"Senior Accountant",leader:false,reportsTo:"priya",photo:"photos/finley.jpg"},
    {id:"casey",name:"Casey Nguyen",title:"FP&A Manager",leader:false,reportsTo:"priya",photo:"photos/casey.jpg"},
    {id:"sam",name:"Sam Chen",title:"Infrastructure Manager",leader:false,reportsTo:"alex",photo:"photos/sam.jpg"},
    {id:"miles",name:"Jordan Miles",title:"Security Manager",leader:false,reportsTo:"alex",photo:"photos/miles.jpg"},
    {id:"harper",name:"Harper Stone",title:"Account Executive",leader:false,reportsTo:"cameron",photo:"photos/harper.jpg"},
    {id:"mia",name:"Mia Alvarez",title:"Sales Development Rep",leader:false,reportsTo:"cameron",photo:"photos/mia.jpg"},
  ];
}

function initials(name){
  const parts=(name||"").trim().split(/\s+/).filter(Boolean);
  const a=(parts[0]||"").slice(0,1);
  const b=(parts[1]||"").slice(0,1) || (parts[0]||"").slice(1,2);
  return (a+b).toUpperCase() || "??";
}

function buildIndex(){
  children.clear();
  for(const p of DATA){
    if(!p.reportsTo) continue;
    if(!children.has(p.reportsTo)) children.set(p.reportsTo, []);
    children.get(p.reportsTo).push(p.id);
  }
}


// --- Selection + Header-based isolate ---
let selectedLeaderId = null;
const isolateBtn = document.getElementById("isolateBtn");
const backBtn = document.getElementById("backBtn");
let FULL_DATA = null;

function clearSelection(){
  selectedLeaderId = null;
  isolateBtn.disabled = true;
  document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected'));
}

function selectLeader(id){
  clearSelection(); clearDeptFocus();
  selectedLeaderId = id;
  isolateBtn.disabled = false;
  const el = document.querySelector(`.node[data-id="${CSS.escape(id)}"]`);
  if(el) el.classList.add('selected');
}

function isolateSelected(){
  if(!selectedLeaderId) return;
  FULL_DATA = DATA.map(p=>({...p}));
  animateIsolate(leaderId);

  // build index from snapshot
  const idx = new Map();
  for(const p of FULL_DATA){
    if(!p.reportsTo) continue;
    if(!idx.has(p.reportsTo)) idx.set(p.reportsTo, []);
    idx.get(p.reportsTo).push(p.id);
  }

  const keep = new Set([selectedLeaderId]);
  const q = [selectedLeaderId];
  while(q.length){
    const cur = q.shift();
    (idx.get(cur)||[]).forEach(k=>{
      if(!keep.has(k)){ keep.add(k); q.push(k); }
    });
  }

  DATA = FULL_DATA.filter(p=>keep.has(p.id)).map(p=>{
    if(p.id===selectedLeaderId) return {...p, reportsTo:null};
    return {...p};
  });

  backBtn.style.display="inline-block";
  isolateBtn.disabled = true;
  selectedLeaderId = null;
  layoutStarburst();
  render();
  centerChart();
  centerChart();
}
isolateBtn.onclick = isolateSelected;


function animateIsolate(leaderId){
  document.querySelectorAll('.node').forEach(n=>{
    if(n.dataset.id!==leaderId) n.classList.add('fade-out');
  });
  const rootEl = document.querySelector(`.node[data-id="${CSS.escape(leaderId)}"]`);
  if(rootEl) rootEl.classList.add('zoom-root');
}

function isolateSelectedDirect(leaderId){
  if(!leaderId) return;
  FULL_DATA = DATA.map(p=>({...p}));
  animateIsolate(leaderId);

  const idx = new Map();
  for(const p of FULL_DATA){
    if(!p.reportsTo) continue;
    if(!idx.has(p.reportsTo)) idx.set(p.reportsTo, []);
    idx.get(p.reportsTo).push(p.id);
  }

  const keep = new Set([leaderId]);
  const q = [leaderId];
  while(q.length){
    const cur = q.shift();
    (idx.get(cur)||[]).forEach(k=>{
      if(!keep.has(k)){ keep.add(k); q.push(k); }
    });
  }

  DATA = FULL_DATA.filter(p=>keep.has(p.id)).map(p=>{
    if(p.id===leaderId) return {...p, reportsTo:null};
    return {...p};
  });

  backBtn.style.display="inline-block";
  layoutStarburst();
  render();
  try{ if(typeof applyDeptFocus==='function') applyDeptFocus(leaderId); }catch(e){}
  centerChart();
  centerChart();
}



backBtn.onclick = ()=>{
  ACTIVE_DEPT_LAYOUT = null;
  ACTIVE_DEPARTMENT = null;

  if(!FULL_DATA) return;
  DATA = FULL_DATA.map(p=>({...p}));
  FULL_DATA = null;
  backBtn.style.display="none";
  clearSelection(); clearDeptFocus();
  layoutStarburst();
  render();
  centerChart();
  centerChart();
};

function rootPerson(){
  return DATA.find(p=>!p.reportsTo) || DATA.find(p=>p.id==="susan") || DATA[0];
}



function clearDeptHaloSVG(){}
function drawDeptHaloSVG(){/* halo removed */}

function responsiveRadii(){
  const w = VIEW.w;
  const h = VIEW.h;
  const min = Math.min(w, h);

  // Hard clamp so lines ALWAYS shorten on small screens
  if(min <= 420) return { leader: 150, staff: 95 };
  if(min <= 600) return { leader: 190, staff: 120 };
  if(min <= 900) return { leader: 230, staff: 145 };
  if(min <= 1200) return { leader: 260, staff: 160 };
  return { leader: 280, staff: 170 };
}

function layoutStarburst(){
  pos.clear(); relOffset.clear(); edges = [];
  buildIndex();
    buildChildrenAll();
    exposeDebug();

  const root = rootPerson();
  pos.set(root.id, {x:CENTER.x, y:CENTER.y});

  const leaders = DATA.filter(p => p.reportsTo === root.id);
  const { leader: leaderRadius, staff: staffRadius } = responsiveRadii();

  leaders.forEach((p,i)=>{
    const a = (i/Math.max(leaders.length,1))*Math.PI*2 - Math.PI/2;
    pos.set(p.id,{x:CENTER.x+Math.cos(a)*leaderRadius, y:CENTER.y+Math.sin(a)*leaderRadius});
    edges.push({from:root.id,to:p.id,kind:"root"});
  });

  // Staff (multi-tier; supports leader -> subleader -> staff, regardless of CSV order)
  const staff = DATA.filter(p => p.reportsTo && p.reportsTo !== root.id);
  const byManager = new Map();
  for(const p of staff){
    if(!byManager.has(p.reportsTo)) byManager.set(p.reportsTo, []);
    byManager.get(p.reportsTo).push(p);
  }

  // Iterative passes: only place children once their manager has a position
  let progressed = true;
  while(progressed){
    progressed = false;

    for(const [managerId, list] of byManager.entries()){
      const mp = pos.get(managerId);
      if(!mp) continue;

      const remaining = list.filter(ch => !pos.has(ch.id));
      if(!remaining.length) continue;

      const mp0 = BASE_POS.get(managerId) || mp;
      const baseAngle = Math.atan2(mp0.y - CENTER.y, mp0.x - CENTER.x);
      const spread = Math.PI / 1.9;

      remaining.forEach((p,i)=>{
        const t = (remaining.length===1) ? 0.5 : (i/(remaining.length-1));
        const a = baseAngle - spread/2 + t*spread;
        const x = mp.x + Math.cos(a)*staffRadius;
        const y = mp.y + Math.sin(a)*staffRadius;
        pos.set(p.id,{x,y});
        relOffset.set(p.id,{dx:x-mp.x, dy:y-mp.y});
        edges.push({from:managerId,to:p.id,kind:"normal"});
        progressed = true;
      });
    }
  }

  // Fallback: place any still-unplaced nodes near their manager (rare)
  for(const p of staff){
    if(pos.has(p.id)) continue;
    const mp = pos.get(p.reportsTo) || {x:CENTER.x, y:CENTER.y};
    const x = mp.x + (Math.random()*40 - 20);
    const y = mp.y + (Math.random()*40 - 20);
    pos.set(p.id,{x,y});
    relOffset.set(p.id,{dx:x-mp.x, dy:y-mp.y});
    edges.push({from:p.reportsTo,to:p.id,kind:"normal"});
  }
  // Capture baseline positions once so future child placement doesn't flip sides after big drags
  if(BASE_POS.size === 0){
    for(const [id, p] of pos.entries()){
      BASE_POS.set(id, {x:p.x, y:p.y});
    }
  }
}


function refreshDeptFocusAfterRender(){
  // When dept-focus is active, re-apply focused-node styling after any render()
  // (render() rebuilds DOM nodes, so prior .focused classes must be reattached).
  const inDeptFocus = document.body.classList.contains("dept-focus");
  if(inDeptFocus){
    const id =
      (typeof FOCUSED_LEADER_ID !== "undefined" && FOCUSED_LEADER_ID) ? FOCUSED_LEADER_ID :
      ((typeof expandedLeader !== "undefined" && expandedLeader) ? expandedLeader : null) ||
      (rootPerson && rootPerson() ? rootPerson().id : null);

    if(id){
      FOCUSED_LEADER_ID = id;
      try{ applyDeptFocus(id); }catch(e){}
      return;
    }
  }

  // Non-dept-focus: keep line styling sane if a leader id is still present
  if(typeof FOCUSED_LEADER_ID !== "undefined" && FOCUSED_LEADER_ID){
    ensureRootFocused();
    updateFocusedLines(FOCUSED_LEADER_ID);
  }
}

function render(){
  // Visible nodes are controlled centrally
  const visible = getVisibleSet();
  const rootId = rootPerson().id;

  // lines (mode-aware: orthogonal in Traditional, diagonal in Starburst)
  renderLinesOnly();

  // nodes
  try{ NODE_EL_BY_ID && NODE_EL_BY_ID.clear && NODE_EL_BY_ID.clear(); }catch(_e){}
  nodesDiv.innerHTML="";
  for(const p of DATA){
    if(!visible.has(p.id)) continue;

    const ppos = pos.get(p.id);
    if(!ppos) continue;

    const d=document.createElement("div");
    const isRoot = !p.reportsTo;
    const isLeader = !!p.leader && p.reportsTo === rootId;

    const isSubLeader = !!p.sub_leader;
    const isStaff = (!isRoot && !isLeader && !isSubLeader);

    d.className="node"+(isLeader?" leader":"")+(isRoot?" root":"")+(isSubLeader?" subleader":"")+(isStaff?" staff":"");
    let expandHintEl = null;
    // Blur other subleaders when one is selected
    if(isSubLeader && selectedSubleader && p.id !== selectedSubleader){
      d.classList.add("deemph");
    }

    // Also deemphasize leader-direct staff when a subleader branch is selected (in case they are visible for any reason)
    try{
      if(isStaff && selectedSubleader && expandedLeader && p.reportsTo === expandedLeader){
        d.classList.add("deemph");
      }
    }catch(_e){}

// Hover hint only for nodes that can expand
    if(nodeHasChildren(p) && !isRoot){
  d.classList.add("expandable");
  const h=document.createElement("div");
  h.className="expand-hint";

  // If this node is currently expanded, show "Close"
  let isOpen = false;

  // Leader expanded (shows its subleaders)
  if(isLeader && expandedLeader === p.id){
    isOpen = true;
  }

  // Subleader expanded (shows its staff) — only within the active expanded leader
  if(!isOpen && p.sub_leader === true && expandedLeader && p.reportsTo === expandedLeader
     && typeof expandedSubleaders !== "undefined" && expandedSubleaders && expandedSubleaders.has(p.id)){
    isOpen = true;
  }

  // Staff-manager expanded (shows its direct reports)
  if(!isOpen && !isRoot && !isLeader && !isSubLeader && typeof selectedStaffManager !== "undefined"
     && selectedStaffManager && selectedStaffManager === p.id){
    isOpen = true;
  }

  h.textContent = isOpen ? "Close" : "Expand";
  expandHintEl = h;
}

    d.dataset.id=p.id;
    try{ NODE_EL_BY_ID && NODE_EL_BY_ID.set && NODE_EL_BY_ID.set(String(p.id), d); }catch(_e){}
    d.style.left=ppos.x+"px";
    d.style.top=ppos.y+"px";

    const c=document.createElement("div");
    c.className="circle";
    if(p.photo){
      const img=document.createElement("img");
      img.src=p.photo; img.draggable = false;
      img.alt=p.name;
      img.onerror=()=>{ c.innerHTML=`<div class="initials">${initials(p.name)}</div>`; };
      c.appendChild(img);
    }else{
      c.innerHTML=`<div class="initials">${initials(p.name)}</div>`;
    }

    const lab=document.createElement("div");
    lab.className="label";
    // small off-axis nudge to avoid label sitting exactly on cross lines
    const root = rootPerson();
    const rp = pos.get(root.id);
    const dx = ppos.x - rp.x;
    const dy = ppos.y - rp.y;
    const nudgeY = 0;
    lab.style.transform = `translateY(-50%)`;
    lab.innerHTML=`<div class="label-box">${(p.department && (p.leader || p.id===rootPerson().id)) ? `<div class="dept">${escapeHtml(p.department.toUpperCase())}</div>` : ``}<div class="name">${escapeHtml(p.name)}</div><div class="title">${escapeHtml(p.title||"")}</div></div><div class="card-hint">Open card</div>`;

    const cw=document.createElement("div");
    cw.className="circle-wrap";
    cw.appendChild(c);
    if(expandHintEl) cw.appendChild(expandHintEl);

    d.appendChild(cw);
    d.appendChild(lab);

    nodesDiv.appendChild(d);

    // --- Click behaviors (single-click leader = toggle staff; double-click anyone = card) ---
    // Stylus (pen) taps often include tiny jitter; treat it as a click unless movement exceeds a small threshold.
    let moved = false;
    let __downX = 0, __downY = 0, __downId = null;
    const TAP_MOVE_TOL = 6;

    function __tapStart(e){
      moved = false;
      __downX = e.clientX; __downY = e.clientY; __downId = e.pointerId;
    }
    function __tapMove(e){
      if(__downId == null || e.pointerId !== __downId) return;
      if(!e.buttons) return;
      const dx = e.clientX - __downX;
      const dy = e.clientY - __downY;
      if(!moved && (Math.abs(dx) > TAP_MOVE_TOL || Math.abs(dy) > TAP_MOVE_TOL)){
        moved = true;
      }
    }
    function __tapEnd(e){
      if(e.pointerId === __downId) __downId = null;
    }

    d.addEventListener("pointerdown", __tapStart);
    d.addEventListener("pointermove", __tapMove);
    d.addEventListener("pointerup", __tapEnd);
    d.addEventListener("pointercancel", __tapEnd);

    // Ensure dragging the photo (circle-wrap) marks as moved so clicks don't fire after drag
    cw.addEventListener("pointerdown", __tapStart);
    cw.addEventListener("pointermove", __tapMove);
    cw.addEventListener("pointerup", __tapEnd);
    cw.addEventListener("pointercancel", __tapEnd);

    lab.addEventListener("pointerdown", __tapStart);
    lab.addEventListener("pointermove", __tapMove);
    lab.addEventListener("pointerup", __tapEnd);
    lab.addEventListener("pointercancel", __tapEnd);

    // Single click: leaders toggle staff
function runSingleClick(e){
if (moved) return;

  // Root (Susan) behaves like focus leader but expands all
  
if(isRoot){
  // Susan click: collapse everything and restore the saved home layout + viewport for the current mode.
  expandedLeader = null;
  try{ expandedSubleaders && expandedSubleaders.clear && expandedSubleaders.clear(); }catch(e){}
  selectedSubleader = null;
  selectedStaffManager = null; window.selectedStaffManager = selectedStaffManager;

  setHeaderTitleText('OFFICE OF THE SECRETARY');

  // Hard reset to the per-mode JSON (layout_starburst.json / layout_traditional.json)
  resetToHomeFromJson(window.LAYOUT_MODE || "starburst", true);
  return;
}


  if(isLeader){

  // Only expandable if this leader actually has direct reports
  if(!nodeHasChildren(p)) return;

// Toggle: clicking the same leader again closes the department (back to Susan overview)
if(expandedLeader === p.id && document.body.classList.contains('dept-focus')){
  clearSelection(); clearDeptFocus(); clearDeptHaloSVG();
  expandedLeader = null;
  expandedSubleaders.clear();
  selectedSubleader = null;
  selectedStaffManager = null; window.selectedStaffManager = selectedStaffManager;
  setHeaderTitleText('OFFICE OF THE SECRETARY');
  render();
  restoreHomeViewport(window.LAYOUT_MODE || "starburst", true);
return;
}

    const headerTitle = document.querySelector('.header-title');
    setHeaderTitleText(p.department || p.name);

    const prevVisible = getVisibleSet();

    expandedLeader = p.id;
    expandedSubleaders.clear(); // start collapsed at the staff level

    selectedSubleader = null;
  selectedStaffManager = null; window.selectedStaffManager = selectedStaffManager;

    render();
    maybePanToReveal(prevVisible, 140);
    ensureNodeVisible(p.id, 180);
    applyDeptFocus(p.id);
    ensureRootFocused();
    updateFocusedLines(p.id);
  }
  // Subleader click: toggle staff under this subleader (only when a leader is expanded)
  const isSubLeader = (expandedLeader && p.sub_leader === true && p.reportsTo === expandedLeader && nodeHasChildren(p));
  if(isSubLeader){
    const prevVisible = getVisibleSet();
    const wasOpen = expandedSubleaders.has(p.id);
    expandedSubleaders.clear();               // hide other subleader staff
    if(!wasOpen){ expandedSubleaders.add(p.id); selectedSubleader = p.id; selectedStaffManager = null; window.selectedStaffManager = selectedStaffManager; }
    else { selectedSubleader = null;
  selectedStaffManager = null; window.selectedStaffManager = selectedStaffManager; }
    
    render();
    maybePanToReveal(prevVisible, 140);
    ensureNodeVisible(p.id, 180);
    // keep leader focus/lines
    applyDeptFocus(expandedLeader);
    ensureRootFocused();
    updateFocusedLines(expandedLeader);
    return;
  }

  // Staff-manager click: toggle direct reports for this staff member (sub-staff)
  const isStaffManager = (expandedLeader && !isRoot && !isLeader && !isSubLeader && hasDirectReports(p.id));
  if(isStaffManager){
    const prevVisible = getVisibleSet();
    selectedStaffManager = (selectedStaffManager === p.id) ? null : p.id; window.selectedStaffManager = selectedStaffManager;

    render();
    maybePanToReveal(prevVisible, 140);
    applyDeptFocus(expandedLeader);
    ensureRootFocused();
    updateFocusedLines(expandedLeader);
    return;
  }

  // Staff click: do nothing
  if(expandedLeader) return;
}

d.addEventListener("click", (e) => {
  if(suppressClickIfDraggingOrJustDragged(e)) return;
  // Hard gate: in dept-focus, only focused (thread) nodes are interactive
  if(document.body.classList.contains('dept-focus')){
    if(d.classList.contains('deemph')){ e.stopPropagation(); return; }
    if(!d.classList.contains('focused') && !d.classList.contains('root')){ e.stopPropagation(); return; }
  }
  try{ if(document.body.classList.contains('dept-focus') && !__isNodeInteractive__(p.id)) { e.stopPropagation(); return; } }catch(_e){}

  // If the click originated in the label, the label handler owns it (card open).
  if (e.target && e.target.closest && e.target.closest(".label")) return;

  // Disable photo-click expand/collapse for any node that cannot expand.
  // Staff CAN expand if they have direct reports tied to them in the CSV (reportsTo === their id).
  if (!isRoot && !nodeHasChildren(p)) {
    e.stopPropagation();
    return;
  }

  e.stopPropagation();
  runSingleClick(e);
});

    lab.addEventListener("click", (e) => {
  e.preventDefault();
  e.stopPropagation();
  if (typeof e.stopImmediatePropagation === "function") e.stopImmediatePropagation();
  if (moved) return;
  try{ if(document.body.classList.contains('dept-focus') && !__isNodeInteractive__(p.id)) return; }catch(_e){}
  openPersonCard(p);
});
// Drag handles: photo circle and label move together (same node position)
    // Prevent pointer-capture on the container from hijacking label clicks (label click should open card)
    try{ lab.addEventListener("pointerdown", (ev)=>{ ev.stopPropagation(); }); }catch(e){}
    try{ cw.dataset.id = p.id; lab.dataset.id = p.id; }catch(e){}
    enableDrag(cw);
    enableDrag(lab);
  }
  refreshDeptFocusAfterRender();
  if(document.body.classList.contains('dept-focus') && FOCUSED_LEADER_ID){
    try{ drawDeptHaloSVG(FOCUSED_LEADER_ID, getVisibleSet()); }catch(e){}
  }
  try{ if(document.body.classList.contains('dept-focus') && FOCUSED_LEADER_ID){ drawDeptHaloSVG(FOCUSED_LEADER_ID, getVisibleSet()); } }catch(e){}
}

function escapeHtml(s){
}

function escapeHtml(s){
  return String(s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}


// ===============================
// Person Card Modal (single-click anywhere on a node)
// ===============================

function openPersonCard(p){
  if(!p) return;

  // Snapshot focus/expansion state so we can restore line deemphasis after the card closes
  try{
    window.__LAST_CARD_CONTEXT__ = {
      focusedLeaderId: (typeof FOCUSED_LEADER_ID !== "undefined") ? FOCUSED_LEADER_ID : null,
      expandedLeader: (typeof expandedLeader !== "undefined") ? expandedLeader : null,
      selectedSubleader: (typeof selectedSubleader !== "undefined") ? selectedSubleader : null,
      selectedStaffManager: (typeof selectedStaffManager !== "undefined") ? selectedStaffManager : null,
      expandedSubleaders: (typeof expandedSubleaders !== "undefined" && expandedSubleaders && expandedSubleaders.forEach)
        ? Array.from(expandedSubleaders)
        : []
    };
  }catch(e){}

  const modal = document.getElementById("personModal");
  if(!modal) return;

  // Text helpers
  const setText = (id, val) => {
    const el = document.getElementById(id);
    if(el) el.textContent = (val==null || val==="") ? "—" : String(val);
  };

  // Core
  setText("pcName", p.name || "");
  setText("pcTitle", p.title || "");
  setText("pcDept", p.department || "—");

  // Manager (in current view DATA; fallback to SEARCH_INDEX)
  const pool = (SEARCH_INDEX && SEARCH_INDEX.length) ? SEARCH_INDEX : DATA;
  const mgr = pool.find(x => x.id === p.reportsTo);
  setText("pcMgr", mgr ? mgr.name : "—");

  // Phone/Email
  const phoneVal = (p.phone||"").toString().trim();
  const emailVal = (p.email||"").toString().trim();

  setText("pcPhoneText", phoneVal || "—");
  setText("pcEmailText", emailVal || "—");
  setText("pcPhone", phoneVal || "—");
  setText("pcEmail", emailVal || "—");

  const callA = document.getElementById("pcCall");
  if(callA){
    if(phoneVal){
      callA.style.display = "inline-flex";
      callA.href = "tel:" + phoneVal.replace(/[^0-9+]/g,"");
    }else{
      callA.style.display = "none";
      callA.href = "#";
    }
  }

  const mailA = document.getElementById("pcMail");
  if(mailA){
    if(emailVal){
      mailA.style.display = "inline-flex";
      mailA.href = "mailto:" + emailVal;
    }else{
      mailA.style.display = "none";
      mailA.href = "#";
    }
  }

  // Photo + initials fallback
  const img = document.getElementById("pcPhoto");
  const initialsEl = document.getElementById("pcInitials");
  const initials = (p.name||"").trim().split(/\s+/).slice(0,2).map(s=>s[0]||"").join("").toUpperCase();

  if(img && initialsEl){
    if(p.photo){
      img.src = p.photo;
      img.style.display = "block";
      initialsEl.style.display = "none";
      img.onerror = ()=>{ img.style.display="none"; initialsEl.textContent = initials || "??"; initialsEl.style.display="block"; };
    }else{
      img.style.display = "none";
      initialsEl.textContent = initials || "??";
      initialsEl.style.display = "block";
    }
  }

    modal.style.display = "flex";

  // View Department handler (existing logic)
    
    const viewBtn = document.getElementById("pcViewDept");
    if(viewBtn){
      viewBtn.style.display = "block";
      
viewBtn.onclick = ()=>{
  const root = rootPerson();

  // close modal immediately
  modal.style.display = "none";

  // already in this department → no-op
  if(ACTIVE_DEPARTMENT && ACTIVE_DEPARTMENT === p.department){
    return;
  }

  // root goes home
  if(root && p.id === root.id){
    window.location.replace(window.location.pathname + "?home=" + Date.now());
    return;
  }

  const leaderId = p.leader ? p.id : p.reportsTo;
  if(!leaderId) return;

  ACTIVE_DEPARTMENT = p.department;

  isolateSelectedDirect(leaderId);

  loadDeptLayout(p.department).then(layout=>{
    ACTIVE_DEPT_LAYOUT = layout;
    if(layout){
      applyLayout(layout);
    }else{
      const baseline = getBaselineLayout && getBaselineLayout();
      if(baseline) applyLayout(baseline);
    }

    expandedLeader = null;
  expandedSubleaders.clear();
    const headerTitle = document.querySelector('.header-title');
    setHeaderTitleText('OFFICE OF THE SECRETARY');
    DATA.forEach(x=>{ if(x.leader) expandedLeaders.add(x.id); });

    render();
    centerChart();
  });
};

    }

}

// Drag: leader drags staff by stored offsets; Susan/root does NOT drag leaders.
let drag=null;

// Click suppression to prevent accidental activations when finishing a drag over another node.
window.__SUPPRESS_CLICK_UNTIL__ = 0;
window.__DRAGGING__ = false;
function suppressClickIfDraggingOrJustDragged(e){
  const now = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
  if(window.__DRAGGING__ || (window.__SUPPRESS_CLICK_UNTIL__ && now < window.__SUPPRESS_CLICK_UNTIL__)){
    try{
      if(e){
        e.preventDefault();
        e.stopPropagation();
        if(typeof e.stopImmediatePropagation === "function") e.stopImmediatePropagation();
      }
    }catch(_){}
    return true;
  }
  return false;
}

function enableDrag(el){
  el.onpointerdown = (e)=>{
    // Starburst: dragging is always allowed.
    // Traditional: dragging is ONLY allowed when Author Mode is ON.
    const __mode__ = (document.body && document.body.classList.contains("traditional-mode")) ? "traditional" : ((typeof window !== "undefined" && window.LAYOUT_MODE) ? window.LAYOUT_MODE : (typeof LAYOUT_MODE !== "undefined" ? LAYOUT_MODE : "starburst"));

    const __isTraditional__ = (__mode__ === "traditional");
    const __isAuthor__ = (typeof AUTHOR_MODE !== "undefined") ? !!AUTHOR_MODE : !!window.AUTHOR_MODE;
    if(__isTraditional__ && !__isAuthor__){
      return;
    }

    // Start a drag gesture. We suppress subsequent click events if the pointer moved.
    window.__DRAGGING__ = false;
    const nodeEl = el.closest && el.closest(".node") ? el.closest(".node") : el;
    const id = (nodeEl && nodeEl.dataset) ? nodeEl.dataset.id : el.dataset.id;

    const p = pos.get(id);
    if(!id || !p) return;

    // Dept-focus isolation: block drags on any node outside the active thread/branch.
    try{
      if(document.body.classList.contains('dept-focus') && typeof __isNodeInteractive__ === 'function' && !__isNodeInteractive__(id)){
        return;
      }
    }catch(_e){}

    drag={id, nodeEl, sx:e.clientX, sy:e.clientY, ox:p.x, oy:p.y, pid: e.pointerId, moved:false};
    // Subtree drag: dragging any node with direct reports moves its entire subtree
    // (keeps hidden descendants in sync so later expansions don't snap back)
    const hasKids = (CHILDREN_ALL.get(id) && CHILDREN_ALL.get(id).length) || false;
    if(hasKids){
      const desc = collectDescendantsAll(id); // includes self
      const groupIds = [];
      for(const gid of desc){
        ensurePosFromBaseline(gid);
        if(pos.has(gid)) groupIds.push(gid);
      }
      if(groupIds.length > 1){
        drag.groupIds = groupIds;
        drag.groupStart = new Map(groupIds.map(gid => [gid, {x: pos.get(gid).x, y: pos.get(gid).y}]));
      }
    }

    el.setPointerCapture(e.pointerId);
  };

  el.onpointermove = (e)=>{
    if(!drag) return;

    // Mark as a real drag after a small movement threshold.
    if(!drag.moved){
      const dx = Math.abs(e.clientX - drag.sx);
      const dy = Math.abs(e.clientY - drag.sy);
      if(dx + dy >= 10){
        drag.moved = true;
        window.__DRAGGING__ = true;
        document.body.classList.add('is-dragging');
        try{ if(drag && drag.nodeEl) drag.nodeEl.classList.add('dragging'); }catch(_){ }


        // Bring dragged node to front so overlapping background nodes cannot intercept subsequent clicks/drags.
        try{
          const nd = document.getElementById('nodes');
          if(drag && drag.nodeEl && nd && drag.nodeEl.parentElement === nd){
            nd.appendChild(drag.nodeEl);
          }
        }catch(_){}

      }
    }

    // If this handler is attached to an inner handle (photo/label), always move the parent node.
    const nodeEl = drag.nodeEl;
    if(!nodeEl) return;

    const id = drag.id;
    const p = pos.get(id);
    if(!p) return;

    p.x = drag.ox + (e.clientX-drag.sx) / zoom;
    p.y = drag.oy + (e.clientY-drag.sy) / zoom;

    // Traditional: snap dragged node to nearby guides (node centers + junction buses). Hold Alt to disable.
    try{
      const __mode2__ = (typeof window !== "undefined" && window.LAYOUT_MODE) ? window.LAYOUT_MODE : (typeof LAYOUT_MODE !== "undefined" ? LAYOUT_MODE : "starburst");
      if(__mode2__ === "traditional" && drag.moved && !e.altKey && !(drag.groupStart && drag.groupIds)){
        const visible = getVisibleSet();
        const exclude = new Set([id]);
        const guides = __collectTraditionalGuides__(visible, exclude);
        const thresh = 12 / zoom;

        p.x = __snapValue__(p.x, guides.xs, thresh);

        // Prefer snapping the node's junction bus (if it has visible children) so branch "bends" line up.
        try{
          const jm = __traditionalJunctionMap__(visible);
          const jSelf = jm ? jm.get(id) : null;
          if(jSelf && typeof jSelf.yJ === "number"){
            const snappedYJ = __snapValue__(jSelf.yJ, guides.ys, thresh);
            p.y += (snappedYJ - jSelf.yJ);
          }else{
            p.y = __snapValue__(p.y, guides.ys, thresh);
          }
        }catch(_e2){
          p.y = __snapValue__(p.y, guides.ys, thresh);
        }
      }
    }catch(_e){}

    // Department group drag: translate all visible descendants together
    if(drag.groupStart && drag.groupIds){
      let dx = (e.clientX-drag.sx) / zoom;
      let dy = (e.clientY-drag.sy) / zoom;

      // Traditional: snap to nearby existing connector "guides" (node centers + junction buses). Hold Alt to disable.
      try{
        const __mode2__ = (typeof window !== "undefined" && window.LAYOUT_MODE) ? window.LAYOUT_MODE : (typeof LAYOUT_MODE !== "undefined" ? LAYOUT_MODE : "starburst");
        if(__mode2__ === "traditional" && drag.moved && !e.altKey){
          const spSelf = drag.groupStart.get(id);
          if(spSelf){
            let mx = spSelf.x + dx;
            let my = spSelf.y + dy;

            const visible = getVisibleSet();
            const exclude = new Set(drag.groupIds);
            const guides = __collectTraditionalGuides__(visible, exclude);
            const thresh = 12 / zoom;

            mx = __snapValue__(mx, guides.xs, thresh);

            // Prefer snapping the parent's junction bus (if present) so multiple branch bends line up across the chart.
            try{
              const jm = __traditionalJunctionMap__(visible);
              const jSelf = jm ? jm.get(id) : null;
              if(jSelf && typeof jSelf.yJ === "number"){
                const yJTrans = jSelf.yJ + dy;
                const snappedYJ = __snapValue__(yJTrans, guides.ys, thresh);
                dy += (snappedYJ - yJTrans);
                my = spSelf.y + dy;
              }else{
                my = __snapValue__(my, guides.ys, thresh);
                dy = my - spSelf.y;
              }
            }catch(_e2){
              my = __snapValue__(my, guides.ys, thresh);
              dy = my - spSelf.y;
            }

            dx = mx - spSelf.x;
          }
        }
      }catch(_e){}

      for(const gid of drag.groupIds){
        const sp = drag.groupStart.get(gid);
        const gp = pos.get(gid);
        if(!sp || !gp) continue;
        gp.x = sp.x + dx;
        gp.y = sp.y + dy;
      }

      // Update relative offsets so future drags keep the layout stable
      for(const gid of drag.groupIds){
        if(gid === id) continue;
        const person = DATA.find(x=>x.id===gid);
        if(!person || !person.reportsTo) continue;
        const parentPos = pos.get(person.reportsTo);
        const childPos = pos.get(gid);
        if(parentPos && childPos){
          relOffset.set(gid, {dx: childPos.x - parentPos.x, dy: childPos.y - parentPos.y});
        }
      }

      // Update DOM quickly
      for(const gid of drag.groupIds){
        const el2 = nodesDiv.querySelector(`.node[data-id="${CSS.escape(gid)}"]`);
        const gp = pos.get(gid);
        if(el2 && gp){
          el2.style.left = gp.x + "px";
          el2.style.top  = gp.y + "px";
        }
      }

      renderLinesOnly();

      if(document.body.classList.contains('dept-focus') && typeof drawDeptHaloSVG === 'function'){
        try{
          drawDeptHaloSVG(FOCUSED_LEADER_ID || expandedLeader, getVisibleSet());
        }catch(e){}
      }
      return;
    }

    // move children if dragging a leader (not root)
    const rootId = rootPerson().id;
    if(id !== rootId){
      const kids = children.get(id);
      if(kids){
        for(const kidId of kids){
          const off = relOffset.get(kidId);
          const kp = pos.get(kidId);
          if(!off || !kp) continue;
          kp.x = p.x + off.dx;
          kp.y = p.y + off.dy;
        }
      }
    }

    // if staff dragged, update offset relative to leader
    const person = DATA.find(x=>x.id===id);
    if(person && person.reportsTo){
      const leaderPos = pos.get(person.reportsTo);
      if(leaderPos){
        relOffset.set(id, {dx: p.x - leaderPos.x, dy: p.y - leaderPos.y});
      }
    }

    // update DOM quickly without breaking inner label/circle positioning
    nodeEl.style.left = p.x + "px";
    nodeEl.style.top  = p.y + "px";

    const kids = (id===rootPerson().id) ? null : children.get(id);
    if(kids){
      for(const kidId of kids){
        const kidEl = nodesDiv.querySelector(`.node[data-id="${CSS.escape(kidId)}"]`);
        const kp = pos.get(kidId);
        if(kidEl && kp){
          kidEl.style.left = kp.x + "px";
          kidEl.style.top  = kp.y + "px";
        }
      }
    }

    // redraw lines only
    renderLinesOnly();

    if(document.body.classList.contains('dept-focus') && typeof drawDeptHaloSVG === 'function'){
      try{
        drawDeptHaloSVG(FOCUSED_LEADER_ID || expandedLeader, getVisibleSet());
      }catch(e){}
    }
  };

  el.onpointerup = (e)=>{
    try{
      if(drag && drag.moved){
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        window.__SUPPRESS_CLICK_UNTIL__ = now + 350;
        suppressClickIfDraggingOrJustDragged(e);
      }
    }catch(_){ }
    try{ if(el.releasePointerCapture) el.releasePointerCapture(e.pointerId); }catch(_){ }
    try{ if(drag && drag.nodeEl) drag.nodeEl.classList.remove('dragging'); }catch(_){ }
    drag = null;
    window.__DRAGGING__ = false;
    document.body.classList.remove('is-dragging');
    try{ if(drag && drag.nodeEl) drag.nodeEl.classList.remove('dragging'); }catch(_){ }

  };
  el.onpointercancel = (e)=>{
    try{
      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      window.__SUPPRESS_CLICK_UNTIL__ = now + 350;
      suppressClickIfDraggingOrJustDragged(e);
    }catch(_){ }
    try{ if(el.releasePointerCapture) el.releasePointerCapture(e.pointerId); }catch(_){ }
    try{ if(drag && drag.nodeEl) drag.nodeEl.classList.remove('dragging'); }catch(_){ }
    drag = null;
    window.__DRAGGING__ = false;
    document.body.classList.remove('is-dragging');
    try{ if(drag && drag.nodeEl) drag.nodeEl.classList.remove('dragging'); }catch(_){ }

  };
}


function getVisibleSet(){
  const visible = new Set();
  const rootId = rootPerson().id;

  // Root + direct reports to Root always visible on initial load
  // (This lets you attach subleaders/staff directly to Susan and have them appear without clicking.)
  for(const p of DATA){
    const isRoot = !p.reportsTo;
    const isDirectToRoot = (p.reportsTo === rootId);
    if(isRoot || isDirectToRoot) visible.add(p.id);
  }

// Expanded leader reveals ALL direct reports (not only subleaders)
  if(expandedLeader){
    const directChildIds = new Set();
    for(const p of DATA){
      if(p.reportsTo === expandedLeader){

        // When a specific subleader branch is selected, hide "leader-direct staff" (staff who report directly to the leader).
        // This keeps the selected subleader view clean (mobile portrait) and prevents leader-direct staff from appearing like
        // they belong to the selected subleader's team.
        try{
          const selectingSubleader = (typeof selectedSubleader !== "undefined" && !!selectedSubleader);
          const noStaffMgrFocus = (typeof selectedStaffManager === "undefined" || !selectedStaffManager);
          if(selectingSubleader && noStaffMgrFocus){
            const isDirectLeaderStaff =
              (p.reportsTo === expandedLeader) &&
              (p.id !== rootId) &&
              (p.sub_leader !== true) &&
              (p.leader !== true) &&
              (p.staff === true || typeof p.staff === "undefined");
            if(isDirectLeaderStaff){
              // keep visible; it will be deemphasized when a subleader is selected
            }
          }
        }catch(_e){}

        visible.add(p.id);
        directChildIds.add(p.id);
      }
    }

    // Subleader expansion: show that subleader's direct reports (only for direct children of the expanded leader)
    if(typeof expandedSubleaders !== "undefined" && expandedSubleaders && expandedSubleaders.size){
      for(const sid of expandedSubleaders){
        if(!directChildIds.has(sid)) continue;
        for(const p of DATA){
          if(p.reportsTo === sid) visible.add(p.id);
        }
      }
    }

    // Staff-manager reveal: keep the selected staff manager visible, PLUS keep the "thread" of managers above it.
    // This prevents context nodes (siblings/peers under the parent manager) from disappearing when drilling down
    // (e.g., Leader -> Subleader -> Staff Manager -> Nested Staff Manager).
    if(selectedStaffManager){
      // Build a manager trail from the selected staff manager up to the subleader/leader boundary.
      // Only climb through parents that themselves have direct reports (i.e., are also staff managers).
      const managerTrail = [];
      try{
        let curId = selectedStaffManager;
        while(curId){
          managerTrail.push(curId);
          visible.add(curId);

          const cur = DATA.find(p => p.id === curId);
          if(!cur) break;

          const parentId = cur.reportsTo;
          if(parentId) visible.add(parentId);

          // Stop climbing once we reach the subleader (or leader boundary), or the root.
          if(!parentId || parentId === rootId || parentId === expandedLeader || parentId === selectedSubleader) break;

          // Continue climbing only if the parent is itself a staff manager (has direct reports).
          if(!hasDirectReports(parentId)) break;

          curId = parentId;
        }
      }catch(_e){}

      // For every manager in the trail, keep ALL of its direct reports visible.
      // This keeps siblings (like Fred/Christina) visible as part of the "thread of reports."
      for(const mid of managerTrail){
        for(const p of DATA){
          if(p.reportsTo === mid) visible.add(p.id);
        }
      }

      // Also keep the selected manager's direct reports visible even if something went wrong building the trail.
      if(managerTrail.length === 0){
        visible.add(selectedStaffManager);
        try{
          const sm = DATA.find(p => p.id === selectedStaffManager);
          if(sm && sm.reportsTo) visible.add(sm.reportsTo);
        }catch(_e){}
        for(const p of DATA){
          if(p.reportsTo === selectedStaffManager) visible.add(p.id);
        }
      }
    }
  }

  return visible;
}

function __nodeRadiusPx__(id){
  // Approximate radii based on CSS sizes (keeps line endpoints on the edge of circles)
  const rootId = rootPerson().id;
  const rec = DATA.find(p=>p.id===id);
  if(!rec) return 28;

  if(id === rootId) return 75; // --size-root:150
  if(rec.leader) return 45;    // --size-leader:90
  if(rec.sub_leader) return 32; // --size-subleader:64
  return 27;                   // --size-staff:54
}

function __traditionalJunctionMap__(visible){
  // For Traditional layout: compute a shared "junction" (elbow Y) per parent so sibling branches line up.
  const parentChildren = new Map();
  for(const e of edges){
    if(!visible.has(e.from) || !visible.has(e.to)) continue;
    if(!parentChildren.has(e.from)) parentChildren.set(e.from, []);
    parentChildren.get(e.from).push(e.to);
  }

  const junction = new Map();
  for(const [from, kids] of parentChildren.entries()){
    const a = pos.get(from);
    if(!a || !kids || kids.length === 0) continue;

    const r1 = __nodeRadiusPx__(from);

    // Decide if this parent's children are mostly below or above (usually below in Traditional).
    let sumY = 0, n = 0;
    for(const kidId of kids){
      const b = pos.get(kidId);
      if(!b) continue;
      sumY += b.y; n++;
    }
    if(!n) continue;
    const avgY = sumY / n;
    const sign = (avgY >= a.y) ? 1 : -1;

    const y1Adj = a.y + sign * r1;

    // Use the average child edge (instead of the "highest/closest" child) so one outlier doesn't dictate the bus height.
    let sumAdj = 0, nAdj = 0;
    for(const kidId of kids){
      const b = pos.get(kidId);
      if(!b) continue;
      const r2 = __nodeRadiusPx__(kidId);
      const y2Adj = b.y - sign * r2;
      sumAdj += y2Adj; nAdj++;
    }
    if(!nAdj) continue;
    const target = sumAdj / nAdj;

    // Parent-level override (lets you move the shared bus/junction for ALL child branches)
    let yJ = y1Adj + (target - y1Adj) / 2;
    try{
      const pov = (TRAD_PARENT_OVERRIDES && TRAD_PARENT_OVERRIDES[from]) ? TRAD_PARENT_OVERRIDES[from] : null;
      if(pov && typeof pov.yJ === "number" && isFinite(pov.yJ)) yJ = pov.yJ;
    }catch(_e){}
junction.set(from, { yJ, sign });
  }

  return junction;
}

function __traditionalPoints__(a, b, fromId, toId, j){
  // Orthogonal-only connectors with a shared per-parent junction in Traditional.
  const r1 = __nodeRadiusPx__(fromId);
  const r2 = __nodeRadiusPx__(toId);
  const sign = (j && typeof j.sign === "number") ? j.sign : ((b.y >= a.y) ? 1 : -1);

  const y1Adj = a.y + sign * r1;
  const y2Adj = b.y - sign * r2;

  const yJ = (j && typeof j.yJ === "number") ? j.yJ : (y1Adj + (y2Adj - y1Adj) / 2);

  return [
    [a.x, y1Adj],
    [a.x, yJ],
    [b.x, yJ],
    [b.x, y2Adj]
  ];
}

// Back-compat (used by older code paths if any remain)
function __orthogonalPoints__(a, b, fromId, toId){
  return __traditionalPoints__(a, b, fromId, toId, null);
}

function __collectTraditionalGuides__(visible, excludeSet){
  // Guides are node centers + per-parent junction Ys (so you can align "buses" and branches).
  const xs = [];
  const ys = [];

  for(const id of visible){
    if(excludeSet && excludeSet.has(id)) continue;
    const p = pos.get(id);
    if(!p) continue;
    xs.push(p.x);
    ys.push(p.y);
  }

  try{
    const jm = __traditionalJunctionMap__(visible);
    for(const v of jm.values()){
      if(v && typeof v.yJ === "number") ys.push(v.yJ);
    }
  }catch(_e){}

  return { xs, ys };
}

function __collectTraditionalLineGuides__(visible){
  // Richer guide set for connector editing: includes node centers, junction Ys,
  // and existing connector vertical/horizontal segment coordinates.
  const base = __collectTraditionalGuides__(visible, null);
  const xs = base.xs.slice();
  const ys = base.ys.slice();

  try{
    const jm = __traditionalJunctionMap__(visible);
    for(const e of edges){
      if(!visible.has(e.from) || !visible.has(e.to)) continue;
      const a = pos.get(e.from), b = pos.get(e.to);
      if(!a || !b) continue;
      const key = __edgeKey__(e.from, e.to);
      const ov = (TRAD_EDGE_OVERRIDES && TRAD_EDGE_OVERRIDES[key]) ? TRAD_EDGE_OVERRIDES[key] : null;
      const j = jm ? jm.get(e.from) : null;
      const pts = ov
        ? __customTraditionalPoints__(a, b, e.from, e.to, ov, j)
        : __traditionalPoints__(a, b, e.from, e.to, j);

      for(let i=0;i<pts.length;i++){
        const p = pts[i];
        if(p && isFinite(p[0]) && isFinite(p[1])){ xs.push(p[0]); ys.push(p[1]); }
      }
      for(let i=0;i<pts.length-1;i++){
        const p1 = pts[i], p2 = pts[i+1];
        if(!p1 || !p2) continue;
        if(Math.abs(p1[0]-p2[0]) < 0.001) xs.push(p1[0]);
        if(Math.abs(p1[1]-p2[1]) < 0.001) ys.push(p1[1]);
      }
    }
  }catch(_e){}

  return { xs, ys };
}

function __snapValue__(v, guides, threshold){
  let best = null;
  for(let i=0;i<guides.length;i++){
    const g = guides[i];
    const d = Math.abs(g - v);
    if(d <= threshold && (best === null || d < best.d)){
      best = { v: g, d };
    }
  }
  return best ? best.v : v;
}


function __edgeKey__(fromId, toId){ return `${fromId}->${toId}`; }

function __autoSide__(a, b){
  // Choose a reasonable default side based on relative position (traditional default is usually vertical).
  const dx = b.x - a.x, dy = b.y - a.y;
  if(Math.abs(dy) >= Math.abs(dx)) return (dy >= 0) ? "bottom" : "top";
  return (dx >= 0) ? "right" : "left";
}

function __anchorPoint__(pt, id, side){
  const r = __nodeRadiusPx__(id);
  switch(side){
    case "left":   return { x: pt.x - r, y: pt.y };
    case "right":  return { x: pt.x + r, y: pt.y };
    case "top":    return { x: pt.x, y: pt.y - r };
    case "bottom": return { x: pt.x, y: pt.y + r };
    default:       return { x: pt.x, y: pt.y };
  }
}

function __customTraditionalPoints__(a, b, fromId, toId, ov, j){
  // Orthogonal routing with selectable node sides + movable mid (midX/midY).
  const fromSide = (ov && ov.fromSide && ov.fromSide !== "auto") ? ov.fromSide : __autoSide__(a, b);
  const toSide   = (ov && ov.toSide   && ov.toSide   !== "auto") ? ov.toSide   : __autoSide__(b, a);

  const fromVert = (fromSide === "top" || fromSide === "bottom");
  const toVert   = (toSide   === "top" || toSide   === "bottom");

  const S = __anchorPoint__(a, fromId, fromSide);
  const E = __anchorPoint__(b, toId, toSide);

  // Default midlines: keep the existing sibling junction behavior when possible.
  let midY = (ov && typeof ov.midY === "number") ? ov.midY :
             (j && typeof j.yJ === "number") ? j.yJ :
             (S.y + (E.y - S.y) / 2);

  let midX = (ov && typeof ov.midX === "number") ? ov.midX :
             (S.x + (E.x - S.x) / 2);

  // If the user added manual waypoints, honor them with Manhattan (orthogonal) routing.
  // waypoints: [{x,y}, ...] in SVG coords (excludes endpoints).
  if(ov && Array.isArray(ov.waypoints) && ov.waypoints.length){
    const wps = ov.waypoints
      .filter(p=>p && typeof p.x==="number" && typeof p.y==="number" && isFinite(p.x) && isFinite(p.y))
      .map(p=>({x:p.x,y:p.y}));

    const raw = [S, ...wps, E];

    // Expand each segment into orthogonal steps (H then V). De-dupe consecutive points.
    const out = [];
    const pushPt = (p)=>{
      if(!out.length) { out.push(p); return; }
      const q = out[out.length-1];
      if(Math.abs(p.x-q.x) < 0.001 && Math.abs(p.y-q.y) < 0.001) return;
      out.push(p);
    };

    for(let i=0;i<raw.length-1;i++){
      const P = raw[i], N = raw[i+1];
      pushPt(P);
      if(Math.abs(P.x - N.x) < 0.001 || Math.abs(P.y - N.y) < 0.001){
        // already orthogonal
      }else{
        // insert elbow
        pushPt({x:N.x, y:P.y});
      }
    }
    pushPt(E);

    return out.map(p=>[p.x,p.y]);
  }

  let pts = [];

  if(fromVert && toVert){
    // Classic Traditional: vertical out of parent, shared junction Y, horizontal to child, vertical in.
    pts = [S, {x:S.x,y:midY}, {x:E.x,y:midY}, E];
  }else if(!fromVert && !toVert){
    // Horizontal-to-horizontal: horizontal out, shared junction X, vertical, horizontal in.
    pts = [S, {x:midX,y:S.y}, {x:midX,y:E.y}, E];
  }else{
    // Mixed: 5-point Manhattan polyline: S -> S1 -> M -> E1 -> E
    const S1 = fromVert ? { x: S.x, y: midY } : { x: midX, y: S.y };
    const E1 = toVert   ? { x: E.x, y: midY } : { x: midX, y: E.y };
    const M  = { x: midX, y: midY };
    pts = [S, S1, M, E1, E];
  }

  // De-dupe consecutive identical points (clean SVG).
  pts = pts.filter((p,i,arr)=>{
    if(i===0) return true;
    const q = arr[i-1];
    return !(Math.abs(p.x-q.x) < 0.001 && Math.abs(p.y-q.y) < 0.001);
  });

  return pts.map(p=>[p.x,p.y]);
}

function __ensureHandleGroup__(){
  let g = document.getElementById("lineHandles");
  if(!g){
    g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("id","lineHandles");
    handlesSvg.appendChild(g);
  }
  return g;
}

function __clearLineHandles__(){
  const g = __ensureHandleGroup__();
  g.innerHTML = "";
}

function __renderLineHandles__(visible){
  const g = __ensureHandleGroup__();
  g.innerHTML = "";

  const mode = (document.body && document.body.classList.contains("traditional-mode")) ? "traditional" : ((typeof LAYOUT_MODE !== "undefined" ? LAYOUT_MODE : null) || (window.LAYOUT_MODE || "starburst"));
  if(!(mode === "traditional" && LINE_EDIT_MODE && SELECTED_EDGE)) return;

  const fromId = SELECTED_EDGE.from, toId = SELECTED_EDGE.to;
  if(!visible.has(fromId) || !visible.has(toId)) return;

  const a = pos.get(fromId), b = pos.get(toId);
  if(!a || !b) return;

  const key = __edgeKey__(fromId, toId);
  const ov = (TRAD_EDGE_OVERRIDES && TRAD_EDGE_OVERRIDES[key]) ? TRAD_EDGE_OVERRIDES[key] : null;

  const __juncMap__ = __traditionalJunctionMap__(visible);
  const j = __juncMap__ ? __juncMap__.get(fromId) : null;

  const fromSide = (ov && ov.fromSide && ov.fromSide !== "auto") ? ov.fromSide : __autoSide__(a, b);
  const toSide   = (ov && ov.toSide   && ov.toSide   !== "auto") ? ov.toSide   : __autoSide__(b, a);
  const fromVert = (fromSide === "top" || fromSide === "bottom");
  const toVert   = (toSide   === "top" || toSide   === "bottom");

  const S = __anchorPoint__(a, fromId, fromSide);
  const E = __anchorPoint__(b, toId, toSide);

  const midY = (ov && typeof ov.midY === "number") ? ov.midY :
               (j && typeof j.yJ === "number") ? j.yJ :
               (S.y + (E.y - S.y) / 2);

  const midX = (ov && typeof ov.midX === "number") ? ov.midX :
               (S.x + (E.x - S.x) / 2);

  let M = { x: midX, y: midY };
  if(fromVert && toVert){
    M = { x: (S.x + E.x) / 2, y: midY };
  }else if(!fromVert && !toVert){
    M = { x: midX, y: (S.y + E.y) / 2 };
  }

  // End handles (circles)
  const h1 = document.createElementNS("http://www.w3.org/2000/svg","circle");
  h1.setAttribute("cx", S.x); h1.setAttribute("cy", S.y); h1.setAttribute("r","6");
  h1.setAttribute("class","line-handle line-handle-end");
  h1.setAttribute("pointer-events","all");
  h1.dataset.handle = "from";
  h1.dataset.from = fromId; h1.dataset.to = toId;

  const h1hit = document.createElementNS("http://www.w3.org/2000/svg","circle");
  h1hit.setAttribute("cx", S.x); h1hit.setAttribute("cy", S.y); h1hit.setAttribute("r","18");
  h1hit.setAttribute("fill","transparent");
  h1hit.setAttribute("class","line-handle-hit");
  h1hit.setAttribute("pointer-events","all");
  h1hit.dataset.handle = "from";
  h1hit.dataset.from = fromId; h1hit.dataset.to = toId;


  const h2 = document.createElementNS("http://www.w3.org/2000/svg","circle");
  h2.setAttribute("cx", E.x); h2.setAttribute("cy", E.y); h2.setAttribute("r","6");
  h2.setAttribute("class","line-handle line-handle-end");
  h2.setAttribute("pointer-events","all");
  h2.dataset.handle = "to";
  h2.dataset.from = fromId; h2.dataset.to = toId;

  const h2hit = document.createElementNS("http://www.w3.org/2000/svg","circle");
  h2hit.setAttribute("cx", E.x); h2hit.setAttribute("cy", E.y); h2hit.setAttribute("r","18");
  h2hit.setAttribute("fill","transparent");
  h2hit.setAttribute("class","line-handle-hit");
  h2hit.setAttribute("pointer-events","all");
  h2hit.dataset.handle = "to";
  h2hit.dataset.from = fromId; h2hit.dataset.to = toId;


  // Mid handle (square)
  const hm = document.createElementNS("http://www.w3.org/2000/svg","rect");
  hm.setAttribute("x", M.x - 6); hm.setAttribute("y", M.y - 6);
  hm.setAttribute("width","12"); hm.setAttribute("height","12");
  hm.setAttribute("rx","2");
  hm.setAttribute("class","line-handle line-handle-mid");
  hm.setAttribute("pointer-events","all");
  hm.dataset.handle = "mid";
  hm.dataset.from = fromId; hm.dataset.to = toId;


  // Waypoint handles (extra bends)
  if(ov && Array.isArray(ov.waypoints) && ov.waypoints.length){
    ov.waypoints.forEach((wp, idx)=>{
      if(!wp || typeof wp.x!=="number" || typeof wp.y!=="number") return;
      const hw = document.createElementNS("http://www.w3.org/2000/svg","rect");
      hw.setAttribute("x", wp.x - 5); hw.setAttribute("y", wp.y - 5);
      hw.setAttribute("width","10"); hw.setAttribute("height","10");
      hw.setAttribute("rx","2");
      hw.setAttribute("class","line-handle line-handle-wp");
      hw.setAttribute("pointer-events","all");
      hw.dataset.handle = "wp";
      hw.dataset.idx = String(idx);
      hw.dataset.from = fromId; hw.dataset.to = toId;
      g.appendChild(hw);
    });
  }

  // Parent bus/junction guide + handle (shared across all branches from this parent)
  try{
    const kids = [];
    for(const e of edges){
      if(e.from === fromId && visible.has(e.to)) kids.push(e.to);
    }
    if(kids.length >= 2){
      const jm2 = __traditionalJunctionMap__(visible);
      const jj = jm2 ? jm2.get(fromId) : null;
      const yBus = (jj && typeof jj.yJ === "number") ? jj.yJ : midY;

      let xMin = null, xMax = null;
      for(const kidId of kids){
        const kp = pos.get(kidId);
        if(!kp) continue;
        if(xMin === null){ xMin = kp.x; xMax = kp.x; }
        else { xMin = Math.min(xMin, kp.x); xMax = Math.max(xMax, kp.x); }
      }
      if(xMin !== null && xMax !== null){
        const bus = document.createElementNS("http://www.w3.org/2000/svg","line");
        bus.setAttribute("x1", xMin); bus.setAttribute("y1", yBus);
        bus.setAttribute("x2", xMax); bus.setAttribute("y2", yBus);
        bus.setAttribute("class","line-bus-guide");
        g.appendChild(bus);

        const hb = document.createElementNS("http://www.w3.org/2000/svg","rect");
        const mx = (xMin + xMax) / 2;
        hb.setAttribute("x", mx - 6); hb.setAttribute("y", yBus - 6);
        hb.setAttribute("width","12"); hb.setAttribute("height","12");
        hb.setAttribute("rx","2");
        hb.setAttribute("class","line-handle line-handle-bus");
        hb.setAttribute("pointer-events","all");
        hb.dataset.handle = "bus";
        hb.dataset.from = fromId; hb.dataset.to = toId;
        g.appendChild(hb);
      }
    }
  }catch(_e){}
  g.appendChild(h1hit);
  g.appendChild(h2hit);
  g.appendChild(h1);
  g.appendChild(hm);
  g.appendChild(h2);
}

__LINE_HANDLE_DRAG__ = null;

function __svgPointFromEvent__(ev){
  const owner = (ev && ev.target && ev.target.ownerSVGElement) ? ev.target.ownerSVGElement : handlesSvg;
  const pt = owner.createSVGPoint();
  pt.x = ev.clientX; pt.y = ev.clientY;
  const ctm = owner.getScreenCTM();
  if(!ctm) return {x:0,y:0};
  const inv = ctm.inverse();
  const p = pt.matrixTransform(inv);
  return { x: p.x, y: p.y };
}

function __sideFromPointer__(center, p){
  const dx = p.x - center.x;
  const dy = p.y - center.y;
  return (Math.abs(dx) > Math.abs(dy)) ? (dx >= 0 ? "right" : "left") : (dy >= 0 ? "bottom" : "top");
}

function __beginLineHandleDrag__(handleType, fromId, toId, ev){
  __LINE_HANDLE_DRAG__ = { handleType, fromId, toId };
  try{ (handlesSvg||svg).setPointerCapture(ev.pointerId); }catch(_e){}
}

function __updateEdgeOverride__(key, patch){
  if(!TRAD_EDGE_OVERRIDES) TRAD_EDGE_OVERRIDES = {};
  if(!TRAD_EDGE_OVERRIDES[key]) TRAD_EDGE_OVERRIDES[key] = { fromSide:"auto", toSide:"auto" };
  Object.assign(TRAD_EDGE_OVERRIDES[key], patch);
  window.TRAD_EDGE_OVERRIDES = TRAD_EDGE_OVERRIDES;
}

function __moveLineHandle__(ev){
  if(!__LINE_HANDLE_DRAG__) return;
  const { handleType, fromId, toId } = __LINE_HANDLE_DRAG__;
  const key = __edgeKey__(fromId, toId);

  const a = pos.get(fromId), b = pos.get(toId);
  if(!a || !b) return;

  const p = __svgPointFromEvent__(ev);
  if(handleType === "from"){
    const side = __sideFromPointer__(a, p);
    __updateEdgeOverride__(key, { fromSide: side });
  }else if(handleType === "to"){
    const side = __sideFromPointer__(b, p);
    __updateEdgeOverride__(key, { toSide: side });
  }else if(handleType === "mid"){
    // Snap midX/midY to nearby guides (node centers + junction Ys)
    const visible = getVisibleSet();
    const guides = __collectTraditionalLineGuides__(visible);
    const snapPx = 10;

    const midX = __snapValue__(p.x, guides.xs, snapPx);
    const midY = __snapValue__(p.y, guides.ys, snapPx);

    __updateEdgeOverride__(key, { midX, midY });
  }else if(handleType === "wp"){
    const ov = (TRAD_EDGE_OVERRIDES && TRAD_EDGE_OVERRIDES[key]) ? TRAD_EDGE_OVERRIDES[key] : null;
    if(!ov) return;
    if(!Array.isArray(ov.waypoints)) ov.waypoints = [];

    const p = __svgPointFromEvent__(ev);
    const visible = getVisibleSet();
    const guides = __collectTraditionalLineGuides__(visible);
    const snapPx = 10;

    const x = __snapValue__(p.x, guides.xs, snapPx);
    const y = __snapValue__(p.y, guides.ys, snapPx);

    const idx = (__LINE_HANDLE_DRAG__ && typeof __LINE_HANDLE_DRAG__.idx === 'number') ? __LINE_HANDLE_DRAG__.idx : null;
    if(idx === null || idx < 0 || idx >= ov.waypoints.length) return;
    ov.waypoints[idx] = { x, y };
    __updateEdgeOverride__(key, { waypoints: ov.waypoints });
  }else if(handleType === "bus"){
    // Parent-level bus/junction Y (shared by all child branches from this parent)
    const visible = getVisibleSet();
    const guides = __collectTraditionalLineGuides__(visible);
    const snapPx = 10;

    const p = __svgPointFromEvent__(ev);
    const y = __snapValue__(p.y, guides.ys, snapPx);

    if(!TRAD_PARENT_OVERRIDES) TRAD_PARENT_OVERRIDES = {};
    if(!TRAD_PARENT_OVERRIDES[fromId]) TRAD_PARENT_OVERRIDES[fromId] = {};
    TRAD_PARENT_OVERRIDES[fromId].yJ = y;
    window.TRAD_PARENT_OVERRIDES = TRAD_PARENT_OVERRIDES;
  }

  renderLinesOnly(); // redraw lines + handles
}

function __endLineHandleDrag__(ev){
  if(!__LINE_HANDLE_DRAG__) return;
  try{ (handlesSvg||svg).releasePointerCapture(ev.pointerId); }catch(_e){}
  __LINE_HANDLE_DRAG__ = null;
}


function renderLinesOnly(){
  const visible = getVisibleSet();
  const __mode__ = (document.body && document.body.classList.contains("traditional-mode")) ? "traditional" : ((typeof window !== "undefined" && window.LAYOUT_MODE) ? window.LAYOUT_MODE : (typeof LAYOUT_MODE !== "undefined" ? LAYOUT_MODE : "starburst"));

  linesG.innerHTML="";

  const __juncMap__ = (__mode__ === "traditional") ? __traditionalJunctionMap__(visible) : null;

  for(const e of edges){
    if(!visible.has(e.from) || !visible.has(e.to)) continue;

    // If a specific subleader branch is selected, do not draw leader→other-subleader lines.
    // (Avoids stray subleader spokes, while keeping leader→direct-staff lines intact.)
    try{
      if(typeof selectedSubleader !== "undefined" && selectedSubleader &&
         typeof expandedLeader !== "undefined" && expandedLeader &&
         e.from === expandedLeader){
        const toP = DATA.find(x=>x.id===e.to);
        if(toP && toP.sub_leader === true && e.to !== selectedSubleader){
          continue;
        }
      }
    }catch(_e){}

    const a = pos.get(e.from), b = pos.get(e.to);
    if(!a || !b) continue;

    if(__mode__ === "traditional"){
      const key = __edgeKey__(e.from, e.to);
      const ov = (TRAD_EDGE_OVERRIDES && TRAD_EDGE_OVERRIDES[key]) ? TRAD_EDGE_OVERRIDES[key] : null;
      const pts = ov
        ? __customTraditionalPoints__(a, b, e.from, e.to, ov, __juncMap__ ? __juncMap__.get(e.from) : null)
        : __traditionalPoints__(a, b, e.from, e.to, __juncMap__ ? __juncMap__.get(e.from) : null);
      const pl = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      pl.setAttribute("points", pts.map(p=>`${p[0]},${p[1]}`).join(" "));
      pl.setAttribute("fill","none");
      pl.setAttribute("data-from", e.from);
      pl.setAttribute("data-to", e.to);
      pl.setAttribute("data-edgekey", __edgeKey__(e.from, e.to));
      pl.setAttribute("class", "line" + (e.kind === "root" ? " root" : ""));
      linesG.appendChild(pl);
    }else{
      const l = document.createElementNS("http://www.w3.org/2000/svg","line");
      l.setAttribute("x1", a.x); l.setAttribute("y1", a.y);
      l.setAttribute("x2", b.x); l.setAttribute("y2", b.y);
      l.setAttribute("data-from", e.from);
      l.setAttribute("data-to", e.to);
      l.setAttribute("class", "line" + (e.kind === "root" ? " root" : ""));
      linesG.appendChild(l);
    }
  }

  // Draw line edit handles (Traditional-only)
  try{ __renderLineHandles__(visible); }catch(_e){}

  // Re-apply focused line styling after redraw (dept-focus mode)
  if(document.body.classList.contains('dept-focus') && typeof updateFocusedLines === 'function' && FOCUSED_LEADER_ID){
    updateFocusedLines(FOCUSED_LEADER_ID);
  }
}

// Upload

function normalizeRows(rows){
  return rows.map(r=>{
    const o={};
    for(const k in r) o[String(k).trim().toLowerCase()] = r[k];
    const id=String(o.id||"").trim();
    const name=String(o.name||"").trim();
    const title=String(o.title||"").trim();
    const department=String(o.department||"").trim();
    // role booleans from CSV
    const isLeader = String(o.leader||"").trim().toLowerCase()==="true";
    const isSub = String(o.sub_leader||"").trim().toLowerCase()==="true";
    const isAssistant = String(o.assistant||"").trim().toLowerCase()==="true";
    const isStaff = String(o.staff||"").trim().toLowerCase()==="true";

    const leader = isLeader; // treat sub-leaders as leaders for layout
    const reportsTo = String(o.reports_to || o.reportsto || "").trim();
    const photo=String(o.photo||"").trim();
    const phone=String(o.phone||"").trim();
    const email=String(o.email||"").trim();
    return {id,name,title,leader,sub_leader:isSub,department,phone,email,reportsTo:reportsTo||null,photo};
  }).filter(p=>p.id && p.name);
}


function setHeaderTitleText(text){
  const el = document.querySelector('.header-title');
  if(!el) return;

  el.textContent = text || 'OFFICE OF THE SECRETARY';

  // Always start from CSS-defined size (prevents tiny first-load caching)
  el.style.fontSize = '';

  const minPx = 12;
  const maxIters = 120;
  let iter = 0;

  // Shrink-to-fit loop (decrease inline font-size only if needed)
  while(iter < maxIters && el.scrollWidth > el.clientWidth){
    const fs = parseFloat(window.getComputedStyle(el).fontSize);
    if(!(fs > minPx)) break;
    el.style.fontSize = (fs - 1) + 'px';
    iter++;
  }
}


function nodeHasChildren(p){
  // Any node with at least one direct report is expandable.
  if(!p || !p.id) return false;
  return hasDirectReports(p.id);
}


function hasDirectReports(id){
  for(const p of DATA){
    if(p.reportsTo === id) return true;
  }
  return false;
}

async function parseFile(file){
  const n=file.name.toLowerCase();
  if(n.endsWith(".csv")){
    return new Promise((resolve,reject)=>{
      Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>resolve(r.data||[]),error:reject});
    });
  }
  if(n.endsWith(".xlsx")||n.endsWith(".xls")){
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf,{type:"array"});
    const sheet = wb.Sheets[wb.SheetNames[0]];
    return XLSX.utils.sheet_to_json(sheet,{defval:""});
  }
  throw new Error("Unsupported file type");
}

fileInput.onchange = async ()=>{
  const f=fileInput.files && fileInput.files[0];
  if(!f) return;
  try{
    const raw = await parseFile(f);
    DATA = normalizeRows(raw);
    localStorage.setItem('orgchartData', JSON.stringify(DATA));
    layoutStarburst();
    render();
    try{ if(window.__MOBILE_SYNC__) window.__MOBILE_SYNC__(); }catch(e){}
  }catch(err){
    console.error(err);
    alert("Upload failed. Need headers: id,name,title,leader,reportsTo,photo");
  }finally{
    fileInput.value="";
  }
};


const resetLayoutBtn = document.getElementById("resetLayoutBtn");
const authorModeBtn = document.getElementById("authorModeBtn");
const saveDefaultLayoutBtn = document.getElementById("saveDefaultLayoutBtn");
const clearDefaultLayoutBtn = document.getElementById("clearDefaultLayoutBtn");
const layoutInput = document.getElementById("layoutInput");
const toastEl = document.getElementById("toast");

let AUTHOR_MODE = false;

window.AUTHOR_MODE = AUTHOR_MODE;
let expandedLeaders = new Set(); // legacy
let expandedLeader = null;
let selectedSubleader = null;
  selectedStaffManager = null; window.selectedStaffManager = selectedStaffManager; // active subleader (for UI emphasis)
selectedStaffManager = (typeof selectedStaffManager !== 'undefined') ? selectedStaffManager : null; // active staff-with-reports
window.selectedStaffManager = selectedStaffManager;
  expandedSubleaders.clear();
expandedSubleaders = (typeof expandedSubleaders !== 'undefined' && expandedSubleaders) ? expandedSubleaders : new Set(); // subleaderId -> expanded staff
    const headerTitle = document.querySelector('.header-title');
    setHeaderTitleText('OFFICE OF THE SECRETARY'); // single leader expanded (sub_leaders only)

// Default layout baseline comes from the embedded JSON tag (server-authoritative when you hardcode it)
let DEFAULT_LAYOUT = null;
(function(){
  try{
    const tag = document.getElementById("defaultLayoutJson");
    if(tag){
      const raw = (tag.textContent||"").trim();
      DEFAULT_LAYOUT = raw ? JSON.parse(raw) : null;
    }
  }catch(e){ DEFAULT_LAYOUT = null; }
})();

// Runtime baseline set by "Save Default Layout" (does NOT persist unless you paste/export JSON)
let SAVED_DEFAULT_LAYOUT = null;

function toast(msg){
  if(!toastEl) return;
  toastEl.textContent = msg;
  toastEl.classList.add("show");
  clearTimeout(toastEl.__t);
  toastEl.__t = setTimeout(()=>toastEl.classList.remove("show"), 1400);
}

function getBaselineLayout(){
  return SAVED_DEFAULT_LAYOUT || DEFAULT_LAYOUT;
}


let ACTIVE_DEPT_LAYOUT = null;
let ACTIVE_DEPARTMENT = null;

function deptKey(name){
  return (name||"").toLowerCase().replace(/[^a-z0-9]+/g,"_");
}

async function loadDeptLayout(dept){
  if(!dept) return null;
  const path = `./layout_${deptKey(dept)}.json`;
  try{
    const r = await fetch(path,{cache:"no-store"});
    if(!r.ok) throw 0;
    return await r.json();
  }catch(e){
    return null;
  }
}

// Snapshot current layout into {nodes, rel}
function snapshotLayout(){
  const out = { nodes:{}, rel:{} };
  for(const [id,p] of pos.entries()){
    out.nodes[id] = { x: p.x, y: p.y };
  }
  for(const [id,off] of relOffset.entries()){
    out.rel[id] = { dx: off.dx, dy: off.dy };
  }
  try{
    const ov = (window.TRAD_EDGE_OVERRIDES || TRAD_EDGE_OVERRIDES || {});
    if(ov && typeof ov === 'object') out.edge_overrides = ov;
  }catch(_e){}
  try{
    const pov = (window.TRAD_PARENT_OVERRIDES || TRAD_PARENT_OVERRIDES || {});
    if(pov && typeof pov === 'object') out.trad_parent_overrides = pov;
  }catch(_e){} 

  // Persist viewport (pan/zoom) so each mode can restore its exact "home" framing.
  try{
    out.viewport = { panX: panX, panY: panY, zoom: zoom };
  }catch(_e){}
  return out;
}

// Apply a layout snapshot to current DATA
function applyLayout(layout){
  if(!layout || !layout.nodes) return false;

  // If the loaded layout contains manual connector overrides, apply them (Traditional mode only).
  try{
    if(layout.edge_overrides && typeof layout.edge_overrides === "object"){
      window.TRAD_EDGE_OVERRIDES = JSON.parse(JSON.stringify(layout.edge_overrides));
      TRAD_EDGE_OVERRIDES = window.TRAD_EDGE_OVERRIDES;
    }
  }catch(_e){}

  // If the loaded layout contains Traditional parent bus/junction overrides, apply them.
  try{
    if(layout.trad_parent_overrides && typeof layout.trad_parent_overrides === "object"){
      window.TRAD_PARENT_OVERRIDES = JSON.parse(JSON.stringify(layout.trad_parent_overrides));
      TRAD_PARENT_OVERRIDES = window.TRAD_PARENT_OVERRIDES;
    }
  }catch(_e){}

  pos.clear();
  relOffset.clear();
  edges = [];
  buildIndex();

  // Apply node positions (only for ids that exist in DATA)
  const validIds = new Set(DATA.map(p=>p.id));
  for(const id in layout.nodes){
    if(!validIds.has(id)) continue;
    const p = layout.nodes[id];
    if(!p || typeof p.x!=="number" || typeof p.y!=="number") continue;
    pos.set(id, {x:p.x, y:p.y});
  }

  // Fill any missing ids (so render doesn't drop nodes)
  for(const p of DATA){
    if(!pos.has(p.id)){
      // fallback to starburst positions for that node
      // (safe: compute once and copy its value)
      const tmp = new Map(pos);
      layoutStarburst();
      const sp = pos.get(p.id);
      pos.clear();
      for(const [k,v] of tmp.entries()) pos.set(k,v);
      if(sp) pos.set(p.id, {x:sp.x, y:sp.y});
    }
  }

  // Apply rel offsets (optional)
  if(layout.rel){
    for(const id in layout.rel){
      const off = layout.rel[id];
      if(!off || typeof off.dx!=="number" || typeof off.dy!=="number") continue;
      relOffset.set(id, {dx: off.dx, dy: off.dy});
    }
  }

  // Rebuild edges from current DATA
  const rootId = rootPerson().id;
  for(const p of DATA){
    if(!p.reportsTo) continue;
    edges.push({from:p.reportsTo,to:p.id,kind:(p.reportsTo===rootId?"root":"normal")});
  }
  return true;
}

// Download a JSON file
function downloadJSON(filename, obj){
  const blob = new Blob([JSON.stringify(obj,null,2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
}

// Wire buttons
authorModeBtn && (authorModeBtn.onclick = ()=>{
  AUTHOR_MODE = !AUTHOR_MODE;
  window.AUTHOR_MODE = AUTHOR_MODE;
  authorModeBtn.textContent = AUTHOR_MODE ? "Author Mode: On" : "Author Mode: Off";
  saveDefaultLayoutBtn.disabled = !AUTHOR_MODE;
  const saveTraditionalLayoutBtn = document.getElementById("saveTraditionalLayoutBtn");
  if(saveTraditionalLayoutBtn) saveTraditionalLayoutBtn.disabled = !AUTHOR_MODE;
  toast(AUTHOR_MODE ? "Author Mode ON" : "Author Mode OFF");
});


const exportDeptLayoutBtn = document.getElementById("exportDeptLayoutBtn");


function currentDept(){
  return ACTIVE_DEPARTMENT;
}


authorModeBtn && authorModeBtn.addEventListener("click", ()=>{
  if(exportDeptLayoutBtn){
    exportDeptLayoutBtn.disabled = !AUTHOR_MODE;
  }
});

exportDeptLayoutBtn && (exportDeptLayoutBtn.onclick = ()=>{
  if(!AUTHOR_MODE) return;
  const dept = currentDept();
  if(!dept){
    toast("No department context");
    return;
  }
  const snap = snapshotLayout();
  const key = dept.toLowerCase().replace(/[^a-z0-9]+/g,"_");
  downloadJSON(`layout_${key}.json`, snap);
  toast(`Exported ${dept} layout`);
});


saveDefaultLayoutBtn && (saveDefaultLayoutBtn.onclick = ()=>{
  const snap = snapshotLayout();
  SAVED_DEFAULT_LAYOUT = snap;
  downloadJSON("layout_starburst.json", snap);
  toast("Saved + downloaded layout.json");
});

clearDefaultLayoutBtn && (clearDefaultLayoutBtn.onclick = ()=>{
  SAVED_DEFAULT_LAYOUT = null;
  DEFAULT_LAYOUT = null;
  const tag = document.getElementById("defaultLayoutJson");
  if(tag) tag.textContent = "null";
  toast("Default layout cleared");
});

// Load layout.json
layoutInput && (layoutInput.onchange = async ()=>{
  const f = layoutInput.files && layoutInput.files[0];
  if(!f) return;
  try{
    const text = await f.text();
    const obj = JSON.parse(text);
    SAVED_DEFAULT_LAYOUT = obj;
    const ok = applyLayout(getBaselineLayout());
    if(ok){
      render();
      try{ if(window.__MOBILE_SYNC__) window.__MOBILE_SYNC__(); }catch(e){}
      centerChart();
      toast("Layout loaded");
    }else{
      toast("Layout invalid");
    }
  }catch(e){
    console.error(e);
    toast("Layout load failed");
  }finally{
    layoutInput.value = "";
  }
});


resetLayoutBtn.onclick = ()=>{
  // Reset view/layout to the per-mode saved JSON (and its saved viewport if present)
  // This avoids mode-dependent center/pan math that could fling the traditional layout off-screen.
  resetToHomeFromJson(window.LAYOUT_MODE || "starburst", true);
};

resetBtn.onclick = ()=>{
  localStorage.removeItem('orgchartData');
  DATA = demoData();
  layoutStarburst();
  render();
  centerChart();
  centerChart();
};



// CONFIG: path to hosted CSV (relative to site root)
const HOSTED_CSV_PATH = "./orgchart.csv";
const HOSTED_LAYOUT_PATH = "./layout.json";

// Auto-load hosted CSV on page load (authoritative)

function loadHostedLayout(){
  return fetch(HOSTED_LAYOUT_PATH, { cache: "no-store" })
    .then(r => { if(!r.ok) throw new Error("no layout"); return r.json(); })
    .then(j => {
      DEFAULT_LAYOUT = j;
      toast("Default layout loaded");
    })
    .catch(()=>{});
}

function loadHostedCSV(){
  fetch(HOSTED_CSV_PATH, { cache: "no-store" })
    .then(res => {
      if(!res.ok) throw new Error("no csv");
      return res.text();
    })
    .then(text => {
      Papa.parse(text, {
        header:true,
        skipEmptyLines:true,
        complete: r => {
          const rows = normalizeRows(r.data||[]);
          if(rows.length){
            DATA = rows.map(p=>({sub_leader:false, ...p}));
            if(!SEARCH_INDEX) SEARCH_INDEX = rows.map(x=>({...x}));
            localStorage.setItem("orgchartData", JSON.stringify(DATA));
            layoutStarburst();
            autoLoadLayout(window.LAYOUT_MODE || "traditional");
            render();
            try{ if(window.__MOBILE_SYNC__) window.__MOBILE_SYNC__(); }catch(e){}
            requestAnimationFrame(()=>requestAnimationFrame(()=>{ centerOnNodeBiased(rootPerson().id, 0.5, 0.28, ((window.LAYOUT_MODE || "traditional")==="starburst" ? 150 : 0), true); }));
            try{ setTimeout(()=>__fitOverviewToStage__((window.LAYOUT_MODE || "traditional"), true), 360); }catch(_e){}
            if(!SEARCH_INDEX) SEARCH_INDEX = DATA.map(x=>({...x}));
            // Apply embedded/saved default layout baseline if present
            
  const baseline = ACTIVE_DEPT_LAYOUT || getBaselineLayout();

            if(baseline && applyLayout(baseline)){
              render();
              requestAnimationFrame(()=>requestAnimationFrame(()=>{ centerOnNodeBiased(rootPerson().id, 0.5, 0.28, ((window.LAYOUT_MODE || "traditional")==="starburst" ? 150 : 0), true); }));
            try{ setTimeout(()=>__fitOverviewToStage__((window.LAYOUT_MODE || "traditional"), true), 360); }catch(_e){}
            }

          }
        }
      });
    })
    .catch(()=> {
      // fallback to localStorage or demo
      const saved = localStorage.getItem("orgchartData");
      if(saved){
        try { DATA = JSON.parse(saved); } catch(e){}
      }
      layoutStarburst();
      autoLoadLayout(window.LAYOUT_MODE || "traditional");
      render();
      centerChart();
      if(!SEARCH_INDEX) SEARCH_INDEX = DATA.map(x=>({...x}));
            // Apply embedded/saved default layout baseline if present
            
  const baseline = ACTIVE_DEPT_LAYOUT || getBaselineLayout();

            if(baseline && applyLayout(baseline)){
              render();
              requestAnimationFrame(()=>requestAnimationFrame(()=>{ centerOnNodeBiased(rootPerson().id, 0.5, 0.28, ((window.LAYOUT_MODE || "traditional")==="starburst" ? 150 : 0), true); }));
            try{ setTimeout(()=>__fitOverviewToStage__((window.LAYOUT_MODE || "traditional"), true), 360); }catch(_e){}
            }

    });
}

// Restore last-loaded CSV data if available


// --- Canvas panning: drag empty background to move entire artboard ---
const stageEl = document.getElementById("stage");
const viewportEl = document.getElementById("viewport");
let panState = null;
let bgPointer = null;
let panX = 0, panY = 0;
let zoom = 1;



// ===== Home viewport snapshots (per layout mode) =====
const HOME_VIEWPORT = { starburst: null, traditional: null };

function snapshotHomeViewport(mode){
  mode = mode || (window.LAYOUT_MODE || "starburst");
  HOME_VIEWPORT[mode] = { panX, panY, zoom };
}

function restoreHomeViewport(mode, animate=true){
  mode = mode || (window.LAYOUT_MODE || "starburst");
  const snap = HOME_VIEWPORT[mode];

  // If we don't have a snapshot yet, fall back to centering on root with the same bias used at load
  if(!snap){
    const yOff = (mode === "starburst") ? 150 : 0;
    centerOnNodeBiased(rootPerson().id, 0.5, 0.28, yOff, animate);
    // Snapshot after the center animation settles
    setTimeout(()=>snapshotHomeViewport(mode), 340);
    return;
  }

  if(!animate){
    panX = snap.panX;
    panY = snap.panY;
    zoom = snap.zoom;
    applyTransform();
    return;
  }

  const sx = panX, sy = panY, sz = zoom;
  const dx = snap.panX - sx;
  const dy = snap.panY - sy;
  const dz = snap.zoom - sz;
  const t0 = performance.now();
  const dur = 260;

  function step(t){
    const k = Math.min(1, (t - t0) / dur);
    const kk = k*k*(3-2*k); // smoothstep
    panX = sx + dx * kk;
    panY = sy + dy * kk;
    zoom = sz + dz * kk;
    applyTransform();
    if(k < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}


// ===== Fit overview to current window (per layout mode) =====
// Purpose: On first load and when switching layouts, frame the *overview* so it sits nicely within the stage
// without forcing the chart into a tiny thumbnail.
function __fitOverviewToStage__(mode, animate=true){
  mode = mode || (window.LAYOUT_MODE || "starburst");

  // Ensure we have up-to-date stage dimensions
  let rect;
  try{ rect = stageEl.getBoundingClientRect(); }catch(e){ rect = {width: window.innerWidth, height: window.innerHeight}; }
  const W = Math.max(320, rect.width || 0);
  const H = Math.max(320, rect.height || 0);

  const visible = (typeof getVisibleSet === "function") ? getVisibleSet() : null;
  if(!visible || !visible.size) return;

  // Compute world-space bounds that include BOTH circles and their label boxes.
  // This prevents the view from "favoring" one side due to labels extending outward.
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  // Helper to get the node element for a given id
  const getNodeEl = (id) => {
    try{
      if(typeof NODE_EL_BY_ID !== "undefined" && NODE_EL_BY_ID && typeof NODE_EL_BY_ID.get === "function"){
        const el = NODE_EL_BY_ID.get(id);
        if(el) return el;
      }
    }catch(e){}
    return nodesDiv ? nodesDiv.querySelector(`.node[data-id="${id}"]`) : null;
  };

  // Reasonable fallback circle radius (px) if DOM isn't available yet
  const FALLBACK_R = 42;

  for(const id of visible){
    const p = pos.get(id);
    if(!p) continue;

    const nodeEl = getNodeEl(id);
    const circleEl = nodeEl ? nodeEl.querySelector(".circle") : null;
    const r = circleEl ? (circleEl.offsetWidth || 0) / 2 : FALLBACK_R;

    // Circle bounds
    minX = Math.min(minX, p.x - r);
    maxX = Math.max(maxX, p.x + r);
    minY = Math.min(minY, p.y - r);
    maxY = Math.max(maxY, p.y + r);

    // Label bounds (label box is positioned with left: circleSize/2 and vertically centered)
    const labelBox = nodeEl ? nodeEl.querySelector(".label-box") : null;
    if(labelBox){
      const lw = labelBox.offsetWidth || 0;
      const lh = labelBox.offsetHeight || 0;

      // In layout, label starts at +r from the circle center (matches CSS left: calc(var(--circle-size)/2))
      const lx0 = p.x + r;
      const lx1 = lx0 + lw;
      const ly0 = p.y - (lh / 2);
      const ly1 = p.y + (lh / 2);

      minX = Math.min(minX, lx0);
      maxX = Math.max(maxX, lx1);
      minY = Math.min(minY, ly0);
      maxY = Math.max(maxY, ly1);
    }
  }

  if(!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return;

  // Comfortable uniform padding around the computed bounds
  const PAD = (mode === "traditional") ? 90 : 80;
  const minX2 = minX - PAD;
  const maxX2 = maxX + PAD;
  const minY2 = minY - PAD;
  const maxY2 = maxY + PAD;

  const boxW = Math.max(1, maxX2 - minX2);
  const boxH = Math.max(1, maxY2 - minY2);

  // Fit factor (never upscale above 1.0; never shrink below a readable minimum)
  const zFit = Math.min(W / boxW, H / boxH);
  const MIN_ZOOM_CLAMP = 0.92; // was smaller; keep the overview readable
  const targetZoom = Math.max(MIN_ZOOM_CLAMP, Math.min(1.0, zFit));

  // Center on the *full* bounds (circles + labels)
  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;

  const targetPanX = (W * 0.5) - (cx * targetZoom);
  const targetPanY = (H * 0.5) - (cy * targetZoom);

  // Apply
  if(typeof setView === "function"){
    setView(targetZoom, targetPanX, targetPanY, animate);
  }else{
    window.__ZOOM__ = targetZoom;
    window.__PAN_X__ = targetPanX;
    window.__PAN_Y__ = targetPanY;
    if(typeof render === "function") render();
  }
}



// Reset geometry + viewport from the saved per-mode layout JSON (layout_starburst.json / layout_traditional.json).
// Used when clicking Susan to "close everything and go home".
async function resetToHomeFromJson(mode, animate=true){
  let __usedSavedViewport = false;
  mode = mode || (window.LAYOUT_MODE || "starburst");
  const file = (mode === "traditional") ? "layout_traditional.json" : "layout_starburst.json";

  // Apply saved geometry (fallback to algorithmic if missing)
  try{
    const r = await fetch("./" + file, { cache: "no-store" });
    if(!r.ok) throw 0;
    const layout = await r.json();
    applyLayout(layout);
    // If the saved layout has a viewport, restore it exactly and treat it as "home".
    try{
      if(layout && layout.viewport){
        const v = layout.viewport;
        const vz = Number(v.zoom), vx = Number(v.panX), vy = Number(v.panY);
        if(isFinite(vz) && isFinite(vx) && isFinite(vy)){
          zoom = vz; panX = vx; panY = vy;
          applyTransform();
          __usedSavedViewport = true;
          try{ snapshotHomeViewport(mode); }catch(_e){}
        }
      }
    }catch(_e){}
  }catch(e){
    if(mode === "traditional"){
      layoutTraditional();
    }else{
      const baseline = (typeof getBaselineLayout === "function") ? getBaselineLayout() : null;
      if(!(baseline && applyLayout(baseline))){
        layoutStarburst();
      }
    }
  }

  // Clear focus/selection visuals and render the collapsed overview
  try{ clearSelection && clearSelection(); }catch(e){}
  try{ clearDeptHaloSVG && clearDeptHaloSVG(); }catch(e){}
  try{ clearDeptFocus && clearDeptFocus(); }catch(e){}
  render();

  // If we restored an explicit saved viewport, we're done.
  if(__usedSavedViewport){
    return;
  }

  // Recenter to the home position for this mode, then snapshot it
  const yOff = (mode === "starburst") ? 150 : 0;
  // Reset zoom to the saved "home" zoom for this mode (defaults to 1.0) and recenter on root.
  const snap = (typeof HOME_VIEWPORT !== "undefined" && HOME_VIEWPORT) ? HOME_VIEWPORT[mode] : null;
  const targetZoom = (snap && typeof snap.zoom === "number" && isFinite(snap.zoom)) ? snap.zoom : 1;

  const p = pos.get(rootPerson().id);
  if(!p) return;
  const rect = stageEl.getBoundingClientRect();
  const targetPanX = (rect.width * 0.5) - (p.x * targetZoom);
  const targetPanY = (rect.height * 0.28) + yOff - (p.y * targetZoom);

  if(!animate){
    zoom = targetZoom;
    panX = targetPanX;
    panY = targetPanY;
    applyTransform();
    try{ snapshotHomeViewport(mode); }catch(e){}
  }else{
    const sx = panX, sy = panY, sz = zoom;
    const dx = targetPanX - sx;
    const dy = targetPanY - sy;
    const dz = targetZoom - sz;
    const t0 = performance.now();
    const dur = 260;

    function step(t){
      const k = Math.min(1, (t - t0) / dur);
      const kk = k*k*(3-2*k); // smoothstep
      panX = sx + dx * kk;
      panY = sy + dy * kk;
      zoom = sz + dz * kk;
      applyTransform();
      if(k < 1) requestAnimationFrame(step);
      else { try{ snapshotHomeViewport(mode); }catch(e){} }
    }
    requestAnimationFrame(step);
  }
try{ ensureRootFocused && ensureRootFocused(); }catch(e){}
  try{ updateFocusedLines && updateFocusedLines(rootPerson().id); }catch(e){}
}
function applyTransform(){
  viewportEl.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;

  viewportEl.classList.remove("zoom-low","zoom-mid","zoom-high","zoom-full");
  if(zoom < 0.8){
    viewportEl.classList.add("zoom-low");
  }else if(zoom < 1.2){
    viewportEl.classList.add("zoom-mid");
  }else if(zoom < 1.8){
    viewportEl.classList.add("zoom-high");
  }else{
    viewportEl.classList.add("zoom-full");
  }
}




let FOCUSED_LEADER_ID = null;
// Fast lookup for nodes rebuilt each render()
let NODE_EL_BY_ID = new Map();



// Ensure staff reappear when a leader is clicked
function restoreStaffVisibility(){
  document.querySelectorAll(".node.staff").forEach(n=>{
    n.style.display = "";
  });
}

function collectDescendants(leaderId){
  const kids = new Map();
  for(const p of DATA){
    if(!p.reportsTo) continue;
    if(!kids.has(p.reportsTo)) kids.set(p.reportsTo, []);
    kids.get(p.reportsTo).push(p.id);
  }
  const out = new Set([leaderId]);
  const q = (kids.get(leaderId) || []).slice();
  while(q.length){
    const id = q.shift();
    if(out.has(id)) continue;
    out.add(id);
    const more = kids.get(id);
    if(more) for(const c of more) q.push(c);
  }
  return out;
}


function buildChildrenAll(){
  CHILDREN_ALL.clear();
  for(const p of DATA){
    if(!p || !p.id) continue;
    if(!CHILDREN_ALL.has(p.id)) CHILDREN_ALL.set(p.id, []);
  }
  for(const p of DATA){
    if(!p || !p.id) continue;
    if(p.reportsTo){
      if(!CHILDREN_ALL.has(p.reportsTo)) CHILDREN_ALL.set(p.reportsTo, []);
      CHILDREN_ALL.get(p.reportsTo).push(p.id);
    }
  }
}

function collectDescendantsAll(id){
  const out = [];
  const stack = [id];
  const seen = new Set();
  while(stack.length){
    const cur = stack.pop();
    if(seen.has(cur)) continue;
    seen.add(cur);
    out.push(cur);
    const kids = CHILDREN_ALL.get(cur) || [];
    for(const k of kids) stack.push(k);
  }
  return out;
}

function ensurePosFromBaseline(id){
  if(pos.has(id)) return;
  const p = DATA.find(x => x.id === id);
  if(!p) return;

  const parentId = p.reportsTo;
  if(parentId && pos.has(parentId)){
    const parentPos = pos.get(parentId);
    const bChild = BASE_POS.get(id);
    const bPar = BASE_POS.get(parentId);
    if(bChild && bPar){
      const dx = bChild.x - bPar.x;
      const dy = bChild.y - bPar.y;
      const x = parentPos.x + dx;
      const y = parentPos.y + dy;
      pos.set(id, {x, y});
      relOffset.set(id, {dx, dy});
      return;
    }
    const x = parentPos.x + (Math.random()*40 - 20);
    const y = parentPos.y + (Math.random()*40 - 20);
    pos.set(id, {x, y});
    relOffset.set(id, {dx: x-parentPos.x, dy: y-parentPos.y});
    return;
  }

  const b = BASE_POS.get(id);
  if(b) pos.set(id, {x:b.x, y:b.y});
}



function applyDeptFocus(leaderId){
  // Dept focus = keep only the active reporting thread (ancestors) + the active branch (descendants) crisp.
  // Everything else in the department stays blurred/low-opacity.
  FOCUSED_LEADER_ID = leaderId;
  document.body.classList.add("dept-focus");

  // Clear prior focus flags
  document.querySelectorAll(".node").forEach(n=>n.classList.remove("focused"));

  const visible = getVisibleSet();

  // Determine the deepest active node in the current drill path.
  // Priority: staff-manager selection > selected subleader > leader.
  let activeId = null;
  try{
    if(typeof selectedStaffManager !== "undefined" && selectedStaffManager) activeId = selectedStaffManager;
  }catch(_e){}
  try{
    if(!activeId && window.selectedStaffManager) activeId = window.selectedStaffManager;
  }catch(_e){}
  try{
    if(!activeId && typeof selectedSubleader !== "undefined" && selectedSubleader) activeId = selectedSubleader;
  }catch(_e){}
  if(!activeId) activeId = leaderId;

  const focusIds = new Set();

  // Root always stays crisp
  try{
    const r = rootPerson();
    if(r && r.id) focusIds.add(r.id);
  }catch(_e){}

  // Ancestor chain (active thread)
  const seen = new Set();
  let cur = activeId;
  let guard = 0;
  while(cur && !seen.has(cur) && guard++ < 80){
    seen.add(cur);
    focusIds.add(cur);
    const rec = (DATA || []).find(x=>x && x.id === cur);
    cur = rec ? rec.reportsTo : null;
  }

  // Active branch descendants (only those currently visible)
  try{
    const branch = collectDescendants(activeId);
    for(const id of branch){
      if(!visible.has(id)) continue;
      focusIds.add(id);
    }
  }catch(_e){}

  // Persist focus set for interaction gating
  try{ window.__FOCUS_IDS__ = new Set(focusIds); window.__FOCUS_ACTIVE_ID__ = activeId; window.__FOCUS_LEADER_ID__ = leaderId; }catch(_e){}

  // Apply focus classes
  for(const id of focusIds){
    if(id !== (rootPerson && rootPerson() ? rootPerson().id : null) && !visible.has(id)) continue;    let el = null;
    try{ el = (NODE_EL_BY_ID && NODE_EL_BY_ID.get) ? NODE_EL_BY_ID.get(String(id)) : null; }catch(_e){}
    if(!el){
      try{ el = document.querySelector(`.node[data-id="${CSS.escape(String(id))}"]`); }catch(_e){}
    }
    if(el) el.classList.add("focused");
  }

  updateFocusedLines(leaderId);
  try{ drawDeptHaloSVG(leaderId, visible); }catch(e){}
}



function __isNodeInteractive__(id){
  if(!document.body.classList.contains("dept-focus")) return true;

  // Root always stays interactive
  let rootId = null;
  try{ const r = (typeof rootPerson === "function") ? rootPerson() : null; rootId = (r && r.id) ? r.id : null; }catch(_e){}
  if(rootId != null && id === rootId) return true;

  // In dept-focus, only nodes marked .focused and not .deemph are interactive.
  let el = null;
  try{ el = (NODE_EL_BY_ID && NODE_EL_BY_ID.get) ? NODE_EL_BY_ID.get(String(id)) : null; }catch(_e){}
  if(!el){
    try{
      const all = document.querySelectorAll(".node");
      for(const n of all){
        if(n && n.dataset && String(n.dataset.id) === String(id)){ el = n; break; }
      }
    }catch(_e){}
  }
  if(!el) return false;
  if(el.classList.contains("deemph")) return false;
  return el.classList.contains("focused");
}


function ensureRootFocused(){
  const root = document.querySelector(".node.root");
  if(root) root.classList.add("focused");
}


function updateFocusedLines(leaderId){
  // In dept-focus, fade/blur all lines EXCEPT the current reporting thread (ancestors)
  // + the active branch (descendants of the deepest clicked person).
  document.querySelectorAll(".line").forEach(l=>l.classList.remove("focused-line"));

  const visibleNow = getVisibleSet();

  // Determine the deepest active node in the current drill path.
  let activeId = null;
  try{ if(typeof selectedStaffManager !== "undefined" && selectedStaffManager) activeId = selectedStaffManager; }catch(_e){}
  try{ if(!activeId && window.selectedStaffManager) activeId = window.selectedStaffManager; }catch(_e){}
  try{ if(!activeId && typeof selectedSubleader !== "undefined" && selectedSubleader) activeId = selectedSubleader; }catch(_e){}
  if(!activeId) activeId = leaderId;

  const focusEdges = new Set();
  const ek = (a,b)=> `${a}>>${b}`;
  const addEdge = (a,b)=>{ if(a && b) focusEdges.add(ek(a,b)); };

  // Root -> leader edge always stays crisp (when present)
  try{
    const r = rootPerson();
    if(r && r.id) addEdge(r.id, leaderId);
  }catch(_e){}

  // Ancestor chain edges (active thread)
  const seen = new Set();
  let cur = activeId;
  let guard = 0;
  while(cur && !seen.has(cur) && guard++ < 120){
    seen.add(cur);
    const rec = (DATA || []).find(x=>x && x.id === cur);
    const parent = rec ? rec.reportsTo : null;
    if(parent){
      addEdge(parent, cur);
      cur = parent;
    }else{
      break;
    }
  }

  // Descendant branch edges from activeId (visible only)
  try{
    const childrenBy = new Map();
    for(const p of (DATA || [])){
      if(!p || !p.id) continue;
      const par = p.reportsTo;
      if(!par) continue;
      if(!childrenBy.has(par)) childrenBy.set(par, []);
      childrenBy.get(par).push(p.id);
    }

    const q = [activeId];
    const visited = new Set([activeId]);
    while(q.length){
      const pid = q.shift();
      const kids = childrenBy.get(pid) || [];
      for(const kid of kids){
        if(visited.has(kid)) continue;
        visited.add(kid);
        if(visibleNow.has(pid) && visibleNow.has(kid)) addEdge(pid, kid);
        if(visibleNow.has(kid)) q.push(kid);
      }
    }
  }catch(_e){}

  // Apply focused-line class
  document.querySelectorAll(".line").forEach(l=>{
    const from = l.getAttribute("data-from");
    const to = l.getAttribute("data-to");
    if(focusEdges.has(ek(from, to))) l.classList.add("focused-line");
  });
}

function clearDeptFocus(){

  clearDeptHaloSVG();
  FOCUSED_LEADER_ID = null;
  document.body.classList.remove("dept-focus");
  try{ window.__FOCUS_IDS__ = null; window.__FOCUS_ACTIVE_ID__ = null; window.__FOCUS_LEADER_ID__ = null; }catch(_e){}

  document.querySelectorAll(".node.focused").forEach(n=>n.classList.remove("focused"));
}

function centerOnNode(id, animate=true){
  const p = pos.get(id);
  if(!p) return;

  const rect = stageEl.getBoundingClientRect();
  const screenCX = rect.width / 2;
  const screenCY = rect.height / 2;

  const targetX = screenCX - p.x * zoom;
  const targetY = screenCY - p.y * zoom;

  if(animate){
    viewportEl.style.transition = "transform 420ms cubic-bezier(.2,.8,.2,1)";
  }

  panX = targetX;
  panY = targetY;
  applyTransform();

  if(animate){
    setTimeout(()=>viewportEl.style.transition="", 450);
  }
}

function centerOnNodeBiased(id, xFrac=0.5, yFrac=0.28, yOffsetPxOrAnimate=0, animate=true){
  const p = pos.get(id);
  if(!p) return;
  const rect = stageEl.getBoundingClientRect();
  // Back-compat: older calls used (id, xFrac, yFrac, animate)
  let yOffsetPx = 0;
  if(typeof yOffsetPxOrAnimate === 'boolean'){
    animate = yOffsetPxOrAnimate;
  }else{
    yOffsetPx = Number(yOffsetPxOrAnimate) || 0;
  }


  // Place the node at a biased point (ex: 28% from top) instead of dead center
  const targetPanX = (rect.width * xFrac) - (p.x * zoom);
  const targetPanY = (rect.height * yFrac) + yOffsetPx - (p.y * zoom);

  if(!animate){
    panX = targetPanX;
    panY = targetPanY;
    applyTransform();
    return;
  }

  const sx = panX, sy = panY;
  const dx = targetPanX - sx;
  const dy = targetPanY - sy;
  const t0 = performance.now();
  const dur = 260;

  function step(t){
    const k = Math.min(1, (t - t0) / dur);
    // smoothstep
    const kk = k*k*(3-2*k);
    panX = sx + dx * kk;
    panY = sy + dy * kk;
    applyTransform();
    if(k < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}


function isNodeOnScreen(id, pad=160){
  const p = pos.get(id);
  if(!p) return true;
  const rect = stageEl.getBoundingClientRect();
  const sx = p.x * zoom + panX;
  const sy = p.y * zoom + panY;
  return (sx >= pad && sx <= (rect.width - pad) && sy >= pad && sy <= (rect.height - pad));
}

function ensureNodeVisible(id, pad=160){
  if(!isNodeOnScreen(id, pad)){
    centerOnNode(id, true);
  }
}

// If a click reveals nodes that would land off-screen, gently pan just enough to bring them into view.
// This preserves user-placed geometry; it only adjusts the viewport pan when needed.
function ensureIdsInView(ids, pad=120, animate=true){
  if(!ids || !ids.length) return;
  const rect = stageEl.getBoundingClientRect();

  // Approx visual radius (circle + stroke + some breathing room)
  const rPad = 52;

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for(const id of ids){
    const p = pos.get(id);
    if(!p) continue;
    const sx = p.x * zoom + panX;
    const sy = p.y * zoom + panY;
    minX = Math.min(minX, sx - rPad);
    maxX = Math.max(maxX, sx + rPad);
    minY = Math.min(minY, sy - rPad);
    maxY = Math.max(maxY, sy + rPad);
  }
  if(!isFinite(minX)) return;

  const leftBound = pad;
  const rightBound = rect.width - pad;
  const topBound = pad;
  const bottomBound = rect.height - pad;

  let dx=0, dy=0;

  // Minimal pan to bring bounds inside padded viewport
  if(minX < leftBound) dx = leftBound - minX;
  else if(maxX > rightBound) dx = rightBound - maxX;

  if(minY < topBound) dy = topBound - minY;
  else if(maxY > bottomBound) dy = bottomBound - maxY;

  if(dx === 0 && dy === 0) return;

  const targetPanX = panX + dx;
  const targetPanY = panY + dy;

  if(!animate){
    panX = targetPanX;
    panY = targetPanY;
    applyTransform();
    return;
  }

  const sx0 = panX, sy0 = panY;
  const ddx = targetPanX - sx0;
  const ddy = targetPanY - sy0;
  const t0 = performance.now();
  const dur = 260;

  function step(t){
    const k = Math.min(1, (t - t0) / dur);
    const kk = k*k*(3-2*k);
    panX = sx0 + ddx * kk;
    panY = sy0 + ddy * kk;
    applyTransform();
    if(k < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

function maybePanToReveal(prevVisibleSet, pad=120){
  try{
    const after = getVisibleSet();
    const newly = [];
    after.forEach(id => { if(!prevVisibleSet.has(id)) newly.push(id); });
    // Only pan if the newly revealed nodes would be clipped/off-screen
    ensureIdsInView(newly, pad, true);
  }catch(e){}
}



// Center the current chart geometry in the viewport (no scaling change)
function centerChart(){
  if(!pos.size) return;

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for(const {x,y} of pos.values()){
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
  }
  const chartCX = (minX + maxX) / 2;
  const chartCY = (minY + maxY) / 2;

  const rect = stageEl.getBoundingClientRect();
  const screenCX = rect.width / 2;
  const screenCY = rect.height / 2;

  panX = screenCX - chartCX * zoom;
  panY = screenCY - chartCY * zoom;
  applyTransform();
}



stageEl.addEventListener("pointerdown", (e) => {
  const nodeEl = e.target.closest && e.target.closest(".node");
  // Clicking any node should not clear focus/lines (nodes handle their own click)
  if (nodeEl) return;

  bgPointer = { sx: e.clientX, sy: e.clientY, moved: false };

  // Start panning. NOTE: we only "reset / collapse" on a true background CLICK (no pan movement),
  // handled in pointerup below.
  panState = { sx: e.clientX, sy: e.clientY, ox: panX, oy: panY, moved: false };
  stageEl.setPointerCapture(e.pointerId);
  e.preventDefault();
});

stageEl.addEventListener("pointermove", (e) => {
  if (!panState) return;

  const dx = e.clientX - panState.sx;
  const dy = e.clientY - panState.sy;

  if (!panState.moved && (Math.abs(dx) > 6 || Math.abs(dy) > 6)) {
    panState.moved = true;
    if (bgPointer) bgPointer.moved = true;
  }

  panX = panState.ox + dx;
  panY = panState.oy + dy;

  applyTransform();
  e.preventDefault();
});

stageEl.addEventListener("pointerup", (e) => {
  const wasClick = bgPointer && !bgPointer.moved;

  panState = null;
  try { stageEl.releasePointerCapture(e.pointerId); } catch {}

  if (wasClick) {

    // Default: background click resets to org overview
    clearSelection(); clearDeptFocus();
    expandedLeader = null;
    expandedSubleaders.clear();
    selectedSubleader = null;
    selectedStaffManager = null; window.selectedStaffManager = selectedStaffManager;
    setHeaderTitleText('OFFICE OF THE SECRETARY');
    render();
  }

  bgPointer = null;
});

stageEl.addEventListener("pointercancel", (e) => {
  panState = null;
  bgPointer = null;
  try { stageEl.releasePointerCapture(e.pointerId); } catch {}
});



// --- Desktop zoom: Ctrl / Cmd + wheel ---



stageEl.addEventListener("wheel", (e) => {
  e.preventDefault();

  // Cursor position relative to stage (screen space)
  const rect = stageEl.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // Smooth zoom factor (works well for both mouse + trackpad)
  const ZOOM_SENSITIVITY = 0.0016; // increase for faster zoom
  const scaleFactor = Math.exp(-e.deltaY * ZOOM_SENSITIVITY);

  const minZoom = 0.4;
  const maxZoom = 3.0;

  const prevZoom = zoom;
  const nextZoom = Math.min(maxZoom, Math.max(minZoom, prevZoom * scaleFactor));
  if(nextZoom === prevZoom) return;

  // World point under cursor BEFORE zoom (since transform-origin is 0 0)
  const wx = (mx - panX) / prevZoom;
  const wy = (my - panY) / prevZoom;

  zoom = nextZoom;

  // Adjust pan so the same world point stays under cursor AFTER zoom
  panX = mx - wx * zoom;
  panY = my - wy * zoom;

  applyTransform();
}, { passive:false });






// --- Mobile pinch zoom only (touch devices) ---
let pinchStartDist = null;
let pinchStartZoom = 1;

stageEl.addEventListener("touchstart", (e) => {
  if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    pinchStartDist = Math.hypot(dx, dy);
    pinchStartZoom = zoom;
    e.preventDefault();
  }
}, { passive:false });

stageEl.addEventListener("touchmove", (e) => {
  if (e.touches.length === 2 && pinchStartDist) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.hypot(dx, dy);
    zoom = Math.min(2.5, Math.max(0.5, pinchStartZoom * (dist / pinchStartDist)));
    applyTransform();
    e.preventDefault();
  }
}, { passive:false });

stageEl.addEventListener("touchend", () => {
  pinchStartDist = null;
});


// --- Responsive resize handling ---
// Goal: resizing the window must NOT change node geometry (i.e., must not re-run any layout JSON/algorithm).
// We only preserve the current viewport by anchoring the world-point at the viewport center.
let __RESIZE_RAF__ = null;
let __STAGE_W__ = 0;
let __STAGE_H__ = 0;

function __syncStageRect__(){
  const rect = stageEl.getBoundingClientRect();
  __STAGE_W__ = rect.width;
  __STAGE_H__ = rect.height;
  VIEW.w = __STAGE_W__;
  VIEW.h = __STAGE_H__;
  CENTER.x = VIEW.w / 2;
  CENTER.y = VIEW.h / 2 + 10;
}

window.addEventListener("resize", ()=>{
  if(__RESIZE_RAF__) cancelAnimationFrame(__RESIZE_RAF__);
  __RESIZE_RAF__ = requestAnimationFrame(()=>{
    __RESIZE_RAF__ = null;

    // Use the *previous* stage size as the "old" viewport.
    const oldW = __STAGE_W__ || VIEW.w || stageEl.getBoundingClientRect().width;
    const oldH = __STAGE_H__ || VIEW.h || stageEl.getBoundingClientRect().height;

    // Anchor world point currently at the old viewport center
    const anchorWorldX = (oldW/2 - panX) / zoom;
    const anchorWorldY = (oldH/2 - panY) / zoom;

    // Update stage dimensions (new viewport)
    __syncStageRect__();

    // Restore the anchor world point back to the new viewport center
    panX = (VIEW.w/2) - anchorWorldX * zoom;
    panY = (VIEW.h/2) - anchorWorldY * zoom;
    applyTransform();

    // Defensive: if dept focus is active, re-apply focus classes after any size change.
    // IMPORTANT: applyDeptFocus requires the active leader id; calling it without an id
    // will cause everything except the root to be treated as "non-thread".
    if(document.body.classList.contains("dept-focus")){
      const lid = (
        (typeof FOCUSED_LEADER_ID !== "undefined" && FOCUSED_LEADER_ID) ? FOCUSED_LEADER_ID :
        (typeof expandedLeader !== "undefined" && expandedLeader) ? expandedLeader :
        (typeof CURRENT_LEADER_ID !== "undefined" && CURRENT_LEADER_ID) ? CURRENT_LEADER_ID :
        null
      );
      if(lid) applyDeptFocus(lid);
    }
  });
});

// Init stage rect after DOM paints (prevents 0x0 on first load)
requestAnimationFrame(__syncStageRect__);

// init


// ===============================
// Header Search (site-wide, stable; live picker)
// ===============================
const searchInput = document.getElementById("searchInput");
const searchOverlay = document.getElementById("searchOverlay");
const searchResults = document.getElementById("searchResults");

let activeIndex = -1;

function normalizeStr(s){ return (s||"").toString().toLowerCase(); }

function findMatches(query){
  const q = normalizeStr(query);
  if(!q) return [];
  const pool = SEARCH_INDEX || DATA || [];
  return pool.filter(p=>{
    const hay = [p.name, p.title, p.department].map(normalizeStr).join(" ");
    return hay.includes(q);
  });
}

function rankMatches(query, matches){
  const q = normalizeStr(query);
  return matches.slice().sort((a,b)=>{
    const an = normalizeStr(a.name), bn = normalizeStr(b.name);
    const aStarts = an.startsWith(q) ? 0 : 1;
    const bStarts = bn.startsWith(q) ? 0 : 1;
    if(aStarts !== bStarts) return aStarts - bStarts;
    // leaders first
    const al = a.leader ? 0 : 1;
    const bl = b.leader ? 0 : 1;
    if(al !== bl) return al - bl;
    return an.localeCompare(bn);
  });
}

function positionPicker(){
  if(!searchInput || !searchResults) return;
  const r = searchInput.getBoundingClientRect();
  searchResults.style.left = `${Math.max(16, r.left)}px`;
  searchResults.style.top  = `${r.bottom + 8}px`;
  searchResults.style.width = `${Math.min(420, Math.max(260, r.width))}px`;
}

function getItems(){ return [...(searchResults ? searchResults.querySelectorAll(".search-item") : [])]; }
function setActive(items){
  items.forEach((el,i)=>el.classList.toggle("active", i===activeIndex));
}
function commitActive(){
  const items = getItems();
  if(!items.length) return;
  const el = items[activeIndex >= 0 ? activeIndex : 0];
  if(!el) return;
  const p = (SEARCH_INDEX||DATA).find(x=>x.id===el.dataset.id);
  closePicker();
  searchSelectPerson(p);
}

function closePicker(){
  if(searchOverlay) searchOverlay.classList.remove("open");
  if(searchResults) searchResults.innerHTML = "";
  if(searchOverlay) searchOverlay.setAttribute("aria-hidden","true");
  activeIndex = -1;
}

function openPicker(query, matches){
  if(!searchOverlay || !searchResults) return;
  const list = rankMatches(query, matches).slice(0,6);
  activeIndex = -1;

  searchResults.innerHTML = list.map(p=>{
    const meta = [p.title, p.department].filter(Boolean).join(" — ");
    return `<div class="search-item" role="option" data-id="${p.id}">
      <strong>${escapeHtml(p.name)}</strong>
      ${meta ? `<div class="meta">${escapeHtml(meta)}</div>` : ``}
    </div>`;
  }).join("");

  const items = getItems();
  items.forEach((item,i)=>{
    item.addEventListener("mouseenter", ()=>{ activeIndex = i; setActive(items); });

    item.addEventListener("click", ()=>{
      const p = (SEARCH_INDEX||DATA).find(x=>x.id===item.dataset.id);
      closePicker();
      searchSelectPerson(p);
    });
  });

  positionPicker();
  searchOverlay.classList.add("open");
  searchOverlay.setAttribute("aria-hidden","false");
}


function ensureFullOrgForNavigation(){
  // If we're in a department-only view, DATA has been filtered.
  // Restore full org from SEARCH_INDEX (immutable snapshot) before navigating.
  if(SEARCH_INDEX && Array.isArray(SEARCH_INDEX) && SEARCH_INDEX.length){
    // Restore full dataset
    DATA = SEARCH_INDEX.map(x=>({...x}));
  }
  // Clear department-only state
  if(typeof FULL_DATA !== "undefined") FULL_DATA = null;
  if(typeof backBtn !== "undefined" && backBtn) backBtn.style.display = "none";
  if(typeof clearSelection === "function") clearSelection(); clearDeptFocus();

  expandedLeader = null;
  expandedSubleaders.clear();
    const headerTitle = document.querySelector('.header-title');
    setHeaderTitleText('OFFICE OF THE SECRETARY');
  layoutStarburst();
  render();
  centerChart();
  centerChart();
}


function navigateToPerson(p){
  if(!p) return;

  const root = rootPerson();
  // If searching/selecting root (Susan Bourgeois), behave exactly like Home
  if(root && p.id === root.id){
    window.location.replace(window.location.pathname + "?home=" + Date.now());
    return;
  }

  // Always reset to full org before switching departments
  ensureFullOrgForNavigation();

  const leaderId = p.leader ? p.id : p.reportsTo;
  if(!leaderId) return;

  isolateSelectedDirect(leaderId);

        // Re-apply baseline layout so department view matches main layout geometry
        const baseline = getBaselineLayout && getBaselineLayout();
        if(baseline){
          applyLayout(baseline);
        }

  expandedLeaders.add(leaderId);
  render();
  centerChart();

  requestAnimationFrame(()=>{
    document.querySelectorAll(".node").forEach(n=>n.classList.remove("selected"));
    const el = document.querySelector(`.node[data-id="${CSS.escape(p.id)}"]`);
    if(el) el.classList.add("selected");
  });
}



function searchSelectPerson(p){
  if(!p) return;

  // Ensure staff nodes can appear if we were in Susan-only mode
  if(typeof restoreStaffVisibility === "function") restoreStaffVisibility();

  const root = rootPerson();
  const isRoot = root && p.id === root.id;


  // Leader picked from search: do NOT auto-expand their department.
  // Leaders are already visible on the home view, so we keep the global layout and simply
  // center + open the card (avoids the "explosion" effect).
  if(!isRoot && p.leader === true){
    try{
      // If we were in a department-only filtered view, restore the full org dataset
      if(SEARCH_INDEX && Array.isArray(SEARCH_INDEX) && SEARCH_INDEX.length){
        DATA = SEARCH_INDEX.map(x=>({...x}));
      }
    }catch(_e){}
    try{ if(typeof FULL_DATA !== 'undefined') FULL_DATA = null; }catch(_e){}
    try{ if(typeof backBtn !== 'undefined' && backBtn) backBtn.style.display = 'none'; }catch(_e){}

    try{ if(typeof clearSelection === 'function') clearSelection(); }catch(_e){}
    try{ clearDeptFocus(); }catch(_e){}
    try{ clearDeptHaloSVG(); }catch(_e){}

    expandedLeader = null;
    try{ expandedSubleaders && expandedSubleaders.clear && expandedSubleaders.clear(); }catch(_e){}
    selectedSubleader = null;
    selectedStaffManager = null;

    setHeaderTitleText('OFFICE OF THE SECRETARY');
    try{
      const baseline = (typeof getBaselineLayout === 'function') ? getBaselineLayout() : null;
      if(baseline) applyLayout(baseline);
    }catch(_e){}

    render();
    ensureNodeVisible(p.id, 180);

    document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected'));
    const nodeEl = document.querySelector(`.node[data-id="${CSS.escape(p.id)}"]`);
    if(nodeEl) nodeEl.classList.add('selected');

    if(typeof __MOBILE_PORTRAIT__ !== 'undefined' && __MOBILE_PORTRAIT__){
      try{ __mobileFramePerson__(p.id); }catch(_e){}
    }

    openPersonCard(p);
    return;
  }

  // Helper: get person by id
  const byId = (id)=> (DATA || []).find(x=>x.id===id) || null;

  // Find leader for this person (climb reportsTo)
  function findLeaderId(person){
    if(!person) return null;
    if(person.leader) return person.id;
    let cur = person;
    let guard = 0;
    while(cur && cur.reportsTo && guard++ < 40){
      const parent = byId(cur.reportsTo);
      if(!parent) break;
      if(parent.leader) return parent.id;
      cur = parent;
    }
    return null;
  }

  // Find subleader under the leader for this person (climb until you hit a subleader)
  function findSubleaderId(person, leaderId){
    if(!person || !leaderId) return null;
    if(person.sub_leader === true && person.reportsTo === leaderId) return person.id;

    let cur = person;
    let guard = 0;
    while(cur && cur.reportsTo && guard++ < 40){
      const parent = byId(cur.reportsTo);
      if(!parent) break;
      if(parent.sub_leader === true && parent.reportsTo === leaderId) return parent.id;
      cur = parent;
    }
    return null;
  }

  // Manager for staff expansion is just the direct reportsTo (if they have reports)
  const managerId = p.reportsTo || null;

  // Reset state
  expandedLeader = null;
  expandedSubleaders.clear();
  selectedSubleader = null;
  selectedStaffManager = null;

  if(isRoot){
    // Reset view to root
    setHeaderTitleText('OFFICE OF THE SECRETARY');
    render();
    ensureNodeVisible(p.id, 180);
    applyDeptFocus(root.id);
    ensureRootFocused();
    updateFocusedLines(root.id);
  }else{
    const leaderId = (p.leader ? p.id : findLeaderId(p)) || (p.reportsTo || null);
    if(!leaderId){
      // Fallback: just center
      render();
      ensureNodeVisible(p.id, 180);
      return;
    }

    expandedLeader = leaderId;

    // Set selected subleader for deemphasis (focus path)
    // If searching for a subleader directly, treat them as the selected branch
    if(p.sub_leader === true && p.reportsTo === leaderId){
      selectedSubleader = p.id;
      expandedSubleaders.add(p.id);
    }
    const subId = findSubleaderId(p, leaderId);
    if(subId){
      selectedSubleader = subId;
      // Show staff only for the relevant subleader branch
      expandedSubleaders.add(subId);
    }

    // If the direct manager has reports, expand it so the searched person is visible.
    // IMPORTANT: do NOT do this when the selected person is a LEADER (their manager is the root,
    // which would explode the view by showing all leaders).
    const rootId = root ? root.id : null;
    const isLeaderLike = (p.leader === true) || (p.sub_leader === true);
    if(!isLeaderLike && managerId && hasDirectReports(managerId) && managerId !== rootId){
      selectedStaffManager = managerId;
      // selectedStaffManager will add its direct reports in getVisibleSet.
    }

    // Header: show department name
    const leaderObj = byId(leaderId);
    setHeaderTitleText((leaderObj && leaderObj.department) ? leaderObj.department : (p.department || p.name));

    render();

    // Center on searched person
    ensureNodeVisible(p.id, 180);

    // Apply dept focus styling
    applyDeptFocus(leaderId);
    ensureRootFocused();
    updateFocusedLines(leaderId);
  }

  // Highlight selected person (use existing .selected ring)
  document.querySelectorAll(".node.selected").forEach(n=>n.classList.remove("selected"));
  const nodeEl = document.querySelector(`.node[data-id="${CSS.escape(p.id)}"]`);
  if(nodeEl) nodeEl.classList.add("selected");

  
  // Mobile portrait: frame the selected person before showing the card.
  if(typeof __MOBILE_PORTRAIT__ !== "undefined" && __MOBILE_PORTRAIT__){
    __mobileFramePerson__(p.id);
  }

// Open the person card
  openPersonCard(p);
}

let searchTimer = null;

if(searchInput){
  searchInput.addEventListener("input", ()=>{
    clearTimeout(searchTimer);
    const q = searchInput.value.trim();
    if(!q){ closePicker(); return; }
    searchTimer = setTimeout(()=>{
      const matches = findMatches(q);
      if(matches.length){ openPicker(q, matches); }
      else closePicker();
    }, 120);
  });

  
  searchInput.addEventListener("keydown", (e)=>{
    const items = getItems();

    if(e.key === "ArrowDown" && items.length){
      e.preventDefault();
      activeIndex = (activeIndex + 1) % items.length;
      setActive(items);
      return;
    }
    if(e.key === "ArrowUp" && items.length){
      e.preventDefault();
      activeIndex = (activeIndex - 1 + items.length) % items.length;
      setActive(items);
      return;
    }

    if(e.key === "Enter"){
      e.preventDefault();
      // If picker is open and has items, commit active/first
      if(items.length){
        commitActive();
        return;
      }
      // Otherwise: run first match (original behavior)
      const q = searchInput.value.trim();
      if(!q) return;
      const matches = rankMatches(q, findMatches(q));
      if(matches.length){
        searchSelectPerson(matches[0]);
      }
      return;
    }

    if(e.key === "Escape"){
      closePicker();
      return;
    }
  });

  window.addEventListener("resize", ()=>{
    if(searchOverlay && searchOverlay.classList.contains("open")) positionPicker();
  });
}

if(searchOverlay){
  searchOverlay.addEventListener("click", (e)=>{
    if(e.target === searchOverlay) closePicker();
  });
}


loadHostedLayout().finally(()=>{
  loadHostedCSV();
});

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>





<!-- Person Card Modal -->
<div id="personModal" style="display:none;position:fixed;inset:0;z-index:10050;
     background:transparent;backdrop-filter:blur(6px);
     align-items:center;justify-content:center;">
  <div id="personCard" style="
      position:relative;
      width:420px;max-width:94vw;
      border-radius:20px;
      border:1px solid rgba(255,255,255,.18);
      background:linear-gradient(180deg,#0f172a,#0b1220);
      box-shadow:0 30px 80px rgba(0,0,0,.70);
      padding:18px;">
    <button id="personClose" aria-label="Close"
      style="
        position:absolute;
        top:8px;
        right:8px;
        width:44px;
        height:44px;
        border:1px solid transparent;
        border-radius:12px;
        background:transparent;
        cursor:pointer;
        z-index:9999;
        display:flex;
        align-items:center;
        justify-content:center;
      ">
      <svg width="20" height="20" viewBox="0 0 24 24" aria-hidden="true" style="pointer-events:none;">
        <path d="M18 6L6 18M6 6l12 12"
              stroke="rgba(255,255,255,.9)"
              stroke-width="2.5"
              stroke-linecap="round"/>
      </svg>
    </button>

    <div class="pc-wrap">
      <div class="pc-left">
        <div class="pc-avatar">
          <img id="pcPhoto" style="width:100%;height:100%;object-fit:cover;display:none;">
          <div id="pcInitials" class="pc-initials" style="display:none;">AB</div>
        </div>
      </div>

      <div class="pc-right">
        <div id="pcName"></div>
        <div id="pcTitle"></div>

        <div class="pc-badges">
          <div class="pc-chip dept-chip"><strong>DEPT</strong> <span id="pcDept"></span></div>
          <div class="pc-chip"><strong>REPORTS TO</strong> <span id="pcMgr"></span></div>
        </div>

        <div class="pc-actions">
          <a id="pcCall" class="pc-action" href="#" style="display:none;">📞 <span class="muted" id="pcPhone"></span></a>
          <a id="pcMail" class="pc-action" href="#" style="display:none;">✉️ <span class="muted" id="pcEmail"></span></a>
        </div>

        <!-- removed duplicate phone/email grid -->
<div class="pc-grid" style="display:none">
          <div class="pc-row">
            <div class="k">Phone</div>
            <div class="v" id="pcPhoneText">—</div>
          </div>
          <div class="pc-row">
            <div class="k">Email</div>
            <div class="v" id="pcEmailText">—</div>
          </div>
        </div>

        <button id="pcViewDept">View Department</button>
      </div>
    </div>
  </div>
</div>

<script>
// Person card modal close behaviors

(function(){
  const modal = document.getElementById("personModal");
  const closeBtn = document.getElementById("personClose");
  if(!modal || !closeBtn) return;

  function close(){
    modal.style.display = "none";
    try{
      // Re-assert dept-focus line deemphasis after closing a card (fixes search-open state)
      const leaderId =
        (typeof FOCUSED_LEADER_ID !== "undefined" && FOCUSED_LEADER_ID) ? FOCUSED_LEADER_ID :
        (typeof expandedLeader !== "undefined" && expandedLeader) ? expandedLeader :
        null;

      // Restore the exact focus/expansion context that existed when the card was opened.
      // (Card modal blocks interaction, so this is safe and avoids "extra lines showing" regressions.)
      const ctx = window.__LAST_CARD_CONTEXT__ || null;
      if(ctx && leaderId && (ctx.focusedLeaderId === leaderId || ctx.expandedLeader === leaderId)){
        if(typeof expandedLeader !== "undefined") expandedLeader = ctx.expandedLeader || leaderId;
        if(typeof selectedSubleader !== "undefined") selectedSubleader = ctx.selectedSubleader || null;
        if(typeof selectedStaffManager !== "undefined") selectedStaffManager = ctx.selectedStaffManager || null;

        if(typeof expandedSubleaders !== "undefined" && expandedSubleaders && expandedSubleaders.clear){
          expandedSubleaders.clear();
          (ctx.expandedSubleaders || []).forEach(id => expandedSubleaders.add(id));
        }
      }

      if(leaderId){
        if(typeof applyDeptFocus === "function") applyDeptFocus(leaderId);
        if(typeof renderLinesOnly === "function") renderLinesOnly();
        if(typeof updateFocusedLines === "function") updateFocusedLines(leaderId);
      }
    }catch(e){}
  }

  closeBtn.addEventListener("click", close);
  modal.addEventListener("click", (e)=>{ if(e.target === modal) close(); });
  document.addEventListener("keydown", (e)=>{ if(e.key === "Escape") close(); });
})();

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>


<script>
(function(){
  const menu = document.getElementById("hamburgerMenu");
  const toggle = document.getElementById("hamburgerBtn");
  const header = document.querySelector("header");
  if(!menu || !toggle || !header) return;

  // Move everything in header except: logo img, spacer, resetLayoutBtn, hamburger container
  const keepIds = new Set(["resetLayoutBtn","homeBtn","layoutToggleBtn","hamburgerBtn","hamburgerMenu","searchInput"]);
  const keepClasses = new Set(["spacer","hamburger"]);

  const toMove = [];
  Array.from(header.children).forEach(el=>{
    // keep logo img
    if(el.tagName === "IMG") return;
    // keep spacer
    if(el.classList && keepClasses.has("spacer") && el.classList.contains("spacer")) return;
    // keep hamburger container
    if(el.classList && el.classList.contains("hamburger")) return;
    // keep reset layout
    if(el.id && keepIds.has(el.id)) return;

    // Move labels/buttons (and any leftover strong/span empty placeholders)
    if(el.tagName === "BUTTON" || el.tagName === "LABEL" || el.tagName === "STRONG" || el.tagName === "SPAN"){
      // skip empty strong/span placeholders
      const txt = (el.textContent||"").trim();
      if((el.tagName === "STRONG" || el.tagName === "SPAN") && txt === ""){ el.remove(); return; }
      toMove.push(el);
    }
  });

  toMove.forEach(el=> menu.appendChild(el));

  // Ensure "Save Traditional Layout" exists and sits directly under "Save Starburst Layout"
  // (the menu is built by moving header controls into #hamburgerMenu above)
  (function ensureSaveTraditionalLayoutBtn(){
    let btn = document.getElementById("saveTraditionalLayoutBtn");
    if(!btn){
      btn = document.createElement("button");
      btn.id = "saveTraditionalLayoutBtn";
      btn.textContent = "Save Traditional Layout";
      btn.disabled = !window.AUTHOR_MODE;
    }
    // Sync enabled state with Author Mode and wire handler (download current geometry as layout_traditional.json)
    btn.disabled = !window.AUTHOR_MODE;
    btn.onclick = ()=>{
      if(!window.AUTHOR_MODE) return;
      const snap = snapshotLayout();
      downloadJSON("layout_traditional.json", snap);
      toast("Saved + downloaded layout_traditional.json");
    };

    const starburstBtn = document.getElementById("saveDefaultLayoutBtn");
    if(starburstBtn && starburstBtn.parentElement === menu){
      starburstBtn.insertAdjacentElement("afterend", btn);
    }else if(!menu.contains(btn)){
      menu.appendChild(btn);
    }

    // Keep Edit Connectors directly under Save Traditional (if present)
    const editBtn = document.getElementById("editConnectorsBtn");
    if(editBtn && editBtn.parentElement === menu){
      btn.insertAdjacentElement("afterend", editBtn);
    }
  })();

  // Toggle open/close
  toggle.addEventListener("click", (e)=>{
    e.stopPropagation();
    menu.classList.toggle("open");
  });

  // Close on outside click
  document.addEventListener("click", (e)=>{
    if(!menu.classList.contains("open")) return;
    if(menu.contains(e.target) || e.target === toggle) return;
    menu.classList.remove("open");
  });

  // Close on Escape
  document.addEventListener("keydown", (e)=>{
    if(e.key === "Escape") menu.classList.remove("open");
  });
})();

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>


<script>
const homeBtn = document.getElementById("homeBtn");
if(homeBtn){
  homeBtn.onclick = async (e) => {
    // Reset should reload the saved layout JSON for the CURRENT mode
    // (starburst -> layout_starburst.json, traditional -> layout_traditional.json)
    try{ if(e){ e.preventDefault(); e.stopPropagation(); } }catch(_e){}
    try{
      await resetToHomeFromJson(window.LAYOUT_MODE || "traditional", true);
    }catch(err){
      // ultra-safe fallback: hard reload into traditional if reset function is unavailable
      window.location.replace(window.location.pathname + "?home=" + Date.now());
    }
  };
}

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>


<script>
// Logo acts as Home (full reload, cache-busted)
(function(){
  const logo = document.getElementById("homeLogo");
  if(!logo) return;
  logo.addEventListener("click", ()=>{
    window.location.replace(window.location.pathname + "?home=" + Date.now());
  });
})();

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>


<script>
// ===============================
// Proximity glow (no movement)
// ===============================
(function(){
  const stage = document.getElementById("stage");
  if(!stage) return;
  // Click routing: if a label from another node overlaps a photo, prioritize the photo under the cursor.
  // This prevents "wrong card opens" when label boxes collide with other people's photos.
  let __routingPhotoClick = false;
  stage.addEventListener("click", (e) => {
    if(__routingPhotoClick) return;
    if(suppressClickIfDraggingOrJustDragged(e)) return;

    const x = e.clientX, y = e.clientY;

    // In dept-focus, ONLY allow interaction with focused (thread) nodes.
    // IMPORTANT: this click-router must respect that, otherwise it can "synthetically click"
    // a blurred/background node even when CSS pointer-events are disabled.
    function isNodeInteractive(node){
      if(!node) return false;
      if(document.body.classList.contains("dept-focus")){
        if(node.classList.contains("deemph")) return false;
        if(node.classList.contains("root")) return true;
        return node.classList.contains("focused");
      }
      return true;
    }

    const hitNode = (e.target && e.target.closest) ? e.target.closest(".node") : null;
    // If the user actually clicked inside an interactive node (label, circle, etc), don't reroute.
    if(hitNode && isNodeInteractive(hitNode)) return;

    // Find the closest *interactive* photo circle under the pointer.
    let best = null;
    let bestDist = Infinity;
    stage.querySelectorAll(".circle-wrap").forEach(wrap => {
      const node = wrap.closest(".node");
      if(!isNodeInteractive(node)) return;

      const r = wrap.getBoundingClientRect();
      const rad = Math.min(r.width, r.height) / 2;
      const cx = r.left + r.width / 2;
      const cy = r.top + r.height / 2;
      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist <= rad && dist < bestDist){
        best = wrap;
        bestDist = dist;
      }
    });

    if(!best) return;

    // If the event already hit this photo, do nothing (normal path).
    if(e.target && e.target.closest && e.target.closest(".circle-wrap") === best) return;

    // Route the click to the underlying (interactive) photo.
    __routingPhotoClick = true;
    try{
      e.preventDefault();
      e.stopPropagation();
      if(typeof e.stopImmediatePropagation === "function") e.stopImmediatePropagation();
      best.dispatchEvent(new MouseEvent("click", {
        bubbles: true,
        cancelable: true,
        clientX: x,
        clientY: y
      }));
    } finally {
      __routingPhotoClick = false;
    }
  }, true);



  const RADIUS = 60; // px distance for glow

  stage.addEventListener("mousemove", (e)=>{
    const mx = e.clientX;
    const my = e.clientY;

    document.querySelectorAll(".node").forEach(node=>{
      const circle = node.querySelector(".circle");
      if(!circle) return;

      // Only highlight (glow) nodes that can drill down (have direct reports).
      const id = node.getAttribute("data-id") || (node.dataset ? node.dataset.id : null);
      if(!id || !hasDirectReports(id)){
        circle.classList.remove("glow");
        return;
      }

      // In dept-focus mode, never glow background/blurred nodes.
      if(document.body.classList.contains("dept-focus")){
        if(node.classList.contains("deemph") || (!node.classList.contains("root") && !node.classList.contains("focused"))){
          circle.classList.remove("glow");
          return;
        }
      }

      const r = circle.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const cy = r.top + r.height/2;
      const d = Math.hypot(cx - mx, cy - my);

      if(d < RADIUS){
        circle.classList.add("glow");
      }else{
        circle.classList.remove("glow");
      }
    });
  });

  stage.addEventListener("mouseleave", ()=>{
    document.querySelectorAll(".circle.glow")
      .forEach(c=>c.classList.remove("glow"));
  });
})();

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>


<script>
(function(){
  const wrap = document.getElementById("instructions");
  const t = document.getElementById("instructionsToggle");
  const b = document.getElementById("instructionsBody");
  if(!wrap || !t || !b) return;

  function setOpen(open){
    wrap.classList.toggle("open", !!open);
    t.setAttribute("aria-expanded", open ? "true" : "false");
    const icon = t.querySelector(".howto-icon");
    if(icon){
      icon.textContent = open ? "X" : "!";
    }
  }

  // start collapsed
  setOpen(false);

  // Toggle (prevent the global click-to-close from immediately firing)
  t.addEventListener("click", (e)=>{
    e.stopPropagation();
    setOpen(!wrap.classList.contains("open"));
  });

  t.addEventListener("keydown", (e)=>{
    if(e.key === "Enter" || e.key === " "){
      e.preventDefault();
      e.stopPropagation();
      setOpen(!wrap.classList.contains("open"));
    }
  });

  // Close when clicking anywhere else on the canvas OR inside the open window body.
  // (Clicking the toggle itself is handled above.)
  document.addEventListener("click", (e)=>{
    if(!wrap.classList.contains("open")) return;
    if(t.contains(e.target)) return;
    setOpen(false);
  }, true);
})();
// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>


<script>

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>

<script>
document.addEventListener("DOMContentLoaded", ()=>{
  const btn = document.getElementById("resetLayoutBtn");
  if(btn) btn.remove();
});

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>


<script>
document.addEventListener("DOMContentLoaded", ()=>{
  const b = document.getElementById("exportDeptLayoutBtn");
  if(b) b.remove();
});

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>


<script>

let LAYOUT_MODE = "traditional";


// Per-mode vertical viewport offset (traditional sits ~200px higher)
const MODE_YOFFSET = { starburst: 0, traditional: -200 };
window.LAYOUT_MODE = LAYOUT_MODE;
const layoutToggleBtn = document.getElementById("layoutToggleBtn");

// Set initial toggle label based on the starting mode
if(layoutToggleBtn){
  layoutToggleBtn.textContent = (LAYOUT_MODE === "starburst") ? "View in Traditional" : "View in Starburst";
}


function layoutTraditional(){
  pos.clear(); relOffset.clear(); edges = [];
  buildIndex();

  const root = rootPerson();
  const levelY = 140;
  const colGap = 180;

  const levels = new Map();
  function walk(id, depth){
    if(!levels.has(depth)) levels.set(depth, []);
    levels.get(depth).push(id);
    (children.get(id)||[]).forEach(cid=>walk(cid, depth+1));
  }
  walk(root.id, 0);

  levels.forEach((ids, depth)=>{
    const totalW = (ids.length-1) * colGap;
    ids.forEach((id,i)=>{
      const x = CENTER.x - totalW/2 + i*colGap;
      const y = CENTER.y + depth*levelY;
      pos.set(id, {x,y});
    });
  });

  for(const p of DATA){
    if(p.reportsTo){
      edges.push({from:p.reportsTo,to:p.id,kind:"normal"});
    }
  }
}

// ===== Seamless layout switching (Starburst <-> Traditional) =====
function __getSeamlessAnchorId__(){
  try{
    if(typeof selectedStaffManager !== "undefined" && selectedStaffManager) return selectedStaffManager;
    if(typeof selectedSubleader !== "undefined" && selectedSubleader) return selectedSubleader;
    if(typeof expandedLeader !== "undefined" && expandedLeader) return expandedLeader;
  }catch(e){}
  try{
    const r = rootPerson && rootPerson();
    return r ? r.id : null;
  }catch(e){
    return null;
  }
}

function __screenPos__(id){
  try{
    const p = pos && pos.get ? pos.get(id) : null;
    if(!p) return null;
    return { sx: (p.x * zoom) + panX, sy: (p.y * zoom) + panY };
  }catch(e){
    return null;
  }
}

function __preserveAnchorScreen__(anchorId, anchorScreen){
  if(!anchorId || !anchorScreen) return;
  const p = pos && pos.get ? pos.get(anchorId) : null;
  if(!p) return;

  const newSx = (p.x * zoom) + panX;
  const newSy = (p.y * zoom) + panY;

  panX += (anchorScreen.sx - newSx);
  panY += (anchorScreen.sy - newSy);
  applyTransform();
}

async function __applyModeLayoutSeamless__(mode, anchorId, anchorScreen){
  try{ document.body.classList.toggle("traditional-mode", mode === "traditional"); }catch(_e){}
  if(mode !== "traditional"){
    LINE_EDIT_MODE = false; SELECTED_EDGE = null;
    try{ document.body.classList.remove("line-edit"); }catch(_e){}
    try{ __clearLineHandles__(); }catch(_e){}
  }

  // 1) Prefer explicit per-mode layout JSON (layout_starburst.json / layout_traditional.json).
  // 2) Fallback to algorithmic layout if the JSON is missing.
  const file = mode === "traditional" ? "layout_traditional.json" : "layout_starburst.json";

  try{
    const r = await fetch("./" + file, { cache: "no-store" });
    if(!r.ok) throw 0;
    const layout = await r.json();
    applyLayout(layout);
    render();

    // If this mode's layout JSON includes a saved viewport, honor it immediately on switch.
    try{
      const vp = layout && layout.viewport;
      if(vp && typeof vp.panX === "number" && typeof vp.panY === "number" && typeof vp.zoom === "number"){
        panX = vp.panX; panY = vp.panY; zoom = vp.zoom;
        applyTransform();
        try{
          if(typeof HOME_VIEWPORT !== "undefined" && HOME_VIEWPORT){
            HOME_VIEWPORT[mode] = { panX, panY, zoom };
          }
        }catch(_e){}
        exposeDebug();
        return; // IMPORTANT: skip anchor-preserve + fit, since JSON viewport is authoritative
      }
    }catch(_e){}

    exposeDebug();
  }catch(e){
    if(mode === "traditional"){
      layoutTraditional();
      render();
    }else{
      const baseline = (typeof getBaselineLayout === "function") ? getBaselineLayout() : null;
      if(baseline && applyLayout(baseline)){
        render();
      }else{
        layoutStarburst();
        render();
      }
    }
  }

  // Preserve viewport anchor so the switch feels seamless.
  __preserveAnchorScreen__(anchorId, anchorScreen);

  // After applying the new layout, re-frame the overview so it fits the current window.
  try{ requestAnimationFrame(()=>requestAnimationFrame(()=>__fitOverviewToStage__(mode, true))); }catch(_e){}
}

layoutToggleBtn.onclick = ()=>{
  // Choose an anchor node that represents the user's current context and keep it pinned on-screen.
  const anchorId = __getSeamlessAnchorId__();
  let anchorScreen = anchorId ? __screenPos__(anchorId) : null;

  // Compute a mode-to-mode vertical shift so Traditional starts ~200px higher.
  const prevMode = LAYOUT_MODE;
  const nextMode = (LAYOUT_MODE === "starburst") ? "traditional" : "starburst";
  if(anchorScreen){
    const dy = (MODE_YOFFSET[nextMode] || 0) - (MODE_YOFFSET[prevMode] || 0);
    // anchorScreen is in screen coordinates {sx, sy}
    anchorScreen = { sx: anchorScreen.sx, sy: anchorScreen.sy + dy };
  }

  // Flip mode
  LAYOUT_MODE = nextMode;
  window.LAYOUT_MODE = LAYOUT_MODE;
  try{ document.body.classList.toggle("traditional-mode", nextMode === "traditional"); }catch(_e){}
  if(nextMode !== "traditional"){
    // Leaving Traditional: exit line edit mode.
    LINE_EDIT_MODE = false; SELECTED_EDGE = null;
    try{ document.body.classList.remove("line-edit"); }catch(_e){}
    try{ __clearLineHandles__(); }catch(_e){}
  }

  // Button text describes the *next* action
  layoutToggleBtn.textContent =
    LAYOUT_MODE === "starburst" ? "View in Traditional" : "View in Starburst";

  // Swap geometry only (keep expansion/focus state intact)
  __applyModeLayoutSeamless__(LAYOUT_MODE, anchorId, anchorScreen);
  try{ requestAnimationFrame(()=>requestAnimationFrame(()=>__fitOverviewToStage__(LAYOUT_MODE, true))); }catch(_e){}
};

// ===== Mobile portrait (navigation-first) =====
let __MOBILE_PORTRAIT__ = false;
function __isMobilePortrait__(){
  return window.matchMedia && window.matchMedia("(max-width: 600px) and (orientation: portrait)").matches;
}
function __applyMobilePortraitMode__(){
  const should = __isMobilePortrait__();
  if(should === __MOBILE_PORTRAIT__) return;
  __MOBILE_PORTRAIT__ = should;
  document.body.classList.toggle("mobile-portrait", should);

  if(should){
    // Force Traditional layout for mobile portrait (readable, no drag).
    if((window.LAYOUT_MODE || LAYOUT_MODE) !== "traditional"){
      const anchorId = __getSeamlessAnchorId__();
      const anchorScreen = anchorId ? __screenPos__(anchorId) : null;

      LAYOUT_MODE = "traditional";
      window.LAYOUT_MODE = LAYOUT_MODE;
      try{ document.body.classList.add("traditional-mode"); }catch(_e){}


      if(layoutToggleBtn){
        layoutToggleBtn.textContent = "View in Starburst";
      }

      __applyModeLayoutSeamless__("traditional", anchorId, anchorScreen);
    }
  }
}

// Debounced resize/orientation handling
let __mp_timer__ = null;
function __mp_schedule__(){
  clearTimeout(__mp_timer__);
  __mp_timer__ = setTimeout(__applyMobilePortraitMode__, 120);
}
window.addEventListener("resize", __mp_schedule__);
window.addEventListener("orientationchange", ()=>setTimeout(__applyMobilePortraitMode__, 200));
document.addEventListener("DOMContentLoaded", ()=>setTimeout(__applyMobilePortraitMode__, 0));

// Frame a person nicely on mobile after search selection
function __mobileFramePerson__(id){
  if(!id) return;
  // Slightly zoom out so the node + immediate context fit better on narrow screens.
  const targetZoom = 0.92;
  try{
    zoom = targetZoom;
    applyTransform();
    centerOnNode(id, true);
  }catch(e){}
}



// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>



<script>
document.addEventListener("DOMContentLoaded", ()=>{
  try{ document.body.classList.toggle("traditional-mode", (window.LAYOUT_MODE||"starburst")==="traditional"); }catch(_e){}
  const menu = document.getElementById("hamburgerMenu");
  if(!menu) return;

  // Robust mode/auth detection (some flows set body class before window.LAYOUT_MODE updates)
  function __isTraditional__(){
    try{
      if(document.body && document.body.classList && document.body.classList.contains("traditional-mode")) return true;
    }catch(_e){}
    try{ return (window.LAYOUT_MODE || (typeof LAYOUT_MODE !== "undefined" ? LAYOUT_MODE : "starburst")) === "traditional"; }catch(_e){}
    return false;
  }
  function __isAuthor__(){
    try{ if(typeof AUTHOR_MODE !== "undefined") return !!AUTHOR_MODE; }catch(_e){}
    try{ return !!window.AUTHOR_MODE; }catch(_e){}
    return false;
  }

  let btn = document.getElementById("saveTraditionalLayoutBtn");
  const createdNow = !btn;
  if(!btn){
    btn = document.createElement("button");
    btn.id = "saveTraditionalLayoutBtn";
    btn.textContent = "Save Traditional Layout";
    btn.disabled = true;
  }

  // Place directly under "Save Starburst Layout" in the hamburger menu
  const starburstBtn = document.getElementById("saveDefaultLayoutBtn");
  if(createdNow || !menu.contains(btn)){
    if(starburstBtn && starburstBtn.parentElement === menu){
      starburstBtn.insertAdjacentElement("afterend", btn);
    } else {
      menu.appendChild(btn);
    }
  }

  // Place "Edit Connectors" directly under "Save Traditional Layout"
  const editBtn = document.getElementById("editConnectorsBtn");
  if(editBtn){
    if(btn && btn.parentElement === menu){
      btn.insertAdjacentElement("afterend", editBtn);
    }else{
      menu.appendChild(editBtn);
    }
  }

  function update(){
    const isAuth = __isAuthor__();
    const isTrad = __isTraditional__();
    btn.disabled = !(isAuth && isTrad);
    const editBtn = document.getElementById("editConnectorsBtn");
    if(editBtn){
      // Keep clickable even if our mode/auth detection lags; we gate functionality in the handler.
      editBtn.disabled = false;
      editBtn.classList.toggle("soft-disabled", !(isAuth && isTrad));
      editBtn.textContent = LINE_EDIT_MODE ? "Edit Connectors: On" : "Edit Connectors: Off";
    }
  }
  update();

  // Update enable/disable state when toggles are clicked
  const authorBtn = document.getElementById("authorModeBtn");
  const layoutBtn = document.getElementById("layoutToggleBtn");
  authorBtn && authorBtn.addEventListener("click", ()=>setTimeout(update, 0));
  layoutBtn && layoutBtn.addEventListener("click", ()=>setTimeout(update, 0));
  // Also refresh when opening the hamburger (password gate can cause timing quirks)
  const hambBtn = document.getElementById("hamburgerBtn");
  hambBtn && hambBtn.addEventListener("click", ()=>setTimeout(update, 0));

  btn.onclick = ()=>{
    if(btn.disabled) return;
    const snap = snapshotLayout();
    downloadJSON("layout_traditional.json", snap);
    toast("Saved layout_traditional.json");
  };

  const editBtn = document.getElementById("editConnectorsBtn");
  if(editBtn){
    editBtn.onclick = ()=>{
      // Always allow the toggle to flip. If the user isn't in Traditional+Author,
      // line editing simply won't activate (and we provide a hint).
      LINE_EDIT_MODE = !LINE_EDIT_MODE;
      try{ document.body.classList.toggle("line-edit", LINE_EDIT_MODE); }catch(_e){}

      if(!LINE_EDIT_MODE){
        SELECTED_EDGE = null;
        try{ __clearLineHandles__(); }catch(_e){}
        try{ renderLinesOnly(); }catch(_e){}
        toast("Edit connectors off");
      }else{
        const isAuth = __isAuthor__();
        const isTrad = __isTraditional__();
        if(!(isAuth && isTrad)){
          // Don't force it off; just tell the user what they need.
          toast("Tip: switch to Traditional + Author Mode to edit connectors");
        }else{
          toast("Click a line to edit; drag endpoints + bend");
        }
      }
      update();
    };
  }

  // Expose for other parts of the app to refresh button state after re-renders.
  window.__UPDATE_EDIT_CONNECTORS_UI__ = update;
});

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>


<script>
(function(){
  const PASS = "swordfish";
  let unlocked = false;

  document.addEventListener("click", function(e){
    const btn = e.target.closest && e.target.closest("#hamburgerBtn");
    if(!btn) return;

    if(unlocked) return;

    e.stopImmediatePropagation();
    e.preventDefault();

    const entered = prompt("Enter password:");
    if(entered === PASS){
      unlocked = true;
      btn.click();
    }else{
      alert("Incorrect password.");
    }
  }, true);
})();

// ===== MULTI-TIER ORG CHART SUPPORT =====
function getTier(d){
  if(!d.reports_to) return 0;      // root
  if(d.leader) return 1;           // leader
  if(d.sub_leader) return 2;       // sub leader
  if(d.assistant) return 3;        // assistant
  return 4;                        // staff
}


function shouldRenderInitial(d){
  if(!d.reports_to) return true;   // Susan
  return d.leader === true;
}


function revealForLeader(leader){
  return ALL_DATA.filter(p => {
    if(p.reports_to === leader.id) return true; // sub-leaders

    if(p.staff && p.group_id){
      return ALL_DATA.some(s =>
        s.sub_leader &&
        s.reports_to === leader.id &&
        s.group_id === p.group_id
      );
    }
    return false;
  });
}

</script>


<script>
/* ===============================
   Mobile Drilldown Mode
   =============================== */
(function(){
  const BP = 820;
  let inited = false;

  let stack = [];
  let selectedId = null;

  function getReportsTo(p){
    return (p && (p.reportsTo || p.reports_to || p.reports_to_id || p.reports_toId)) ? (p.reportsTo || p.reports_to || p.reports_to_id || p.reports_toId) : null;
  }

  function pool(){
    const s = (typeof SEARCH_INDEX !== "undefined" && Array.isArray(SEARCH_INDEX) && SEARCH_INDEX && SEARCH_INDEX.length) ? SEARCH_INDEX : null;
    return s || (typeof DATA !== "undefined" && Array.isArray(DATA) ? DATA : []);
  }

  function buildMaps(list){
    const byId = new Map();
    const kids = new Map();
    for(const raw of (list||[])){
      const id = String(raw.id||"").trim();
      if(!id) continue;
      const p = Object.assign({}, raw);
      // normalize id + reportsTo
      p.id = id;
      const rt = getReportsTo(p);
      if(rt != null) p.reportsTo = String(rt).trim();
      byId.set(id, p);
    }
    for(const p of byId.values()){
      const rt = getReportsTo(p);
      if(!rt) continue;
      const parent = String(rt).trim();
      if(!kids.has(parent)) kids.set(parent, []);
      kids.get(parent).push(p.id);
    }
    // stable sort by name
    for(const [k,v] of kids.entries()){
      v.sort((a,b)=>{
        const pa = byId.get(a) || {};
        const pb = byId.get(b) || {};
        return String(pa.name||"").localeCompare(String(pb.name||""), undefined, {sensitivity:"base"});
      });
    }
    return { byId, kids };
  }

  function findRoot(byId){
    for(const p of byId.values()){
      if(!getReportsTo(p)) return p.id;
    }
    // fallback: common ids
    if(byId.has("susan")) return "susan";
    return (byId.keys().next().value) || null;
  }

  function pathToRoot(id, byId){
    const out = [];
    const seen = new Set();
    let cur = id;
    while(cur && !seen.has(cur)){
      seen.add(cur);
      out.push(cur);
      const p = byId.get(cur);
      if(!p) break;
      const rt = getReportsTo(p);
      if(!rt) break;
      cur = String(rt).trim();
      if(cur && !byId.has(cur)) break;
    }
    out.reverse();
    return out;
  }

  function ensureSelected(){
    const { byId } = buildMaps(pool());
    if(selectedId && byId.has(selectedId)) return selectedId;
    const r = findRoot(byId);
    selectedId = r;
    stack = r ? [r] : [];
    return selectedId;
  }

  function setMode(on){
    document.body.classList.toggle("mobile-mode", !!on);
    const app = document.getElementById("mobileApp");
    if(app) app.setAttribute("aria-hidden", on ? "false" : "true");
    if(on){
      initOnce();
      sync(true);
    }else{
      // close mobile search results if open
      try{
        const sr = document.getElementById("mobileSearchResults");
        if(sr) sr.classList.remove("open");
      }catch(e){}
    }
  }

  function wantsMobile(){
    return window.innerWidth <= BP;
  }

  function initOnce(){
    if(inited) return;
    inited = true;

    const mobileSearch = document.getElementById("mobileSearch");
    const mobileSearchResults = document.getElementById("mobileSearchResults");
    const mobileBack = document.getElementById("mobileBack");
    const mobileDesktopBtn = document.getElementById("mobileDesktopBtn");
    const mInfoBtn = document.getElementById("mInfoBtn");
    const mHomeBtn = document.getElementById("mHomeBtn");

    if(mobileDesktopBtn){
      mobileDesktopBtn.addEventListener("click", ()=>{
        // force desktop for this session until resize changes it
        setMode(false);
      });
    }

    if(mobileBack){
      mobileBack.addEventListener("click", ()=>{
        if(stack.length > 1){
          stack.pop();
          selectedId = stack[stack.length-1] || selectedId;
          renderMobile();
        }
      });
    }

    if(mHomeBtn){
      mHomeBtn.addEventListener("click", ()=>{
        const maps = buildMaps(pool());
        const r = findRoot(maps.byId);
        if(r){
          selectedId = r;
          stack = [r];
          renderMobile();
        }
      });
    }

    if(mInfoBtn){
      mInfoBtn.addEventListener("click", ()=>{
        try{
          const maps = buildMaps(pool());
          const p = maps.byId.get(selectedId);
          if(p && typeof openPersonCard === "function") openPersonCard(p);
        }catch(e){}
      });
    }

    // Search behavior
    let searchTimer = null;
    function runSearch(){
      const q = (mobileSearch?.value || "").trim().toLowerCase();
      const list = pool();
      const maps = buildMaps(list);
      if(!q){
        if(mobileSearchResults){
          mobileSearchResults.innerHTML = "";
          mobileSearchResults.classList.remove("open");
        }
        return;
      }
      const hits = [];
      for(const p of maps.byId.values()){
        const hay = (String(p.name||"") + " " + String(p.title||"") + " " + String(p.department||"")).toLowerCase();
        if(hay.includes(q)) hits.push(p);
      }
      hits.sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""), undefined, {sensitivity:"base"}));
      const top = hits.slice(0, 14);
      if(mobileSearchResults){
        mobileSearchResults.innerHTML = top.map(p=>{
          const meta = [p.title, p.department].filter(Boolean).join(" • ");
          return '<div class="m-sr-item" role="option" data-id="'+String(p.id).replaceAll('"',"&quot;")+'">' +
                   '<div class="name">'+escapeHtml(p.name||"")+'</div>' +
                   '<div class="meta">'+escapeHtml(meta||"")+'</div>' +
                 '</div>';
        }).join("");
        mobileSearchResults.classList.add("open");
      }
    }

    if(mobileSearch){
      mobileSearch.addEventListener("input", ()=>{
        clearTimeout(searchTimer);
        searchTimer = setTimeout(runSearch, 60);
      });
      mobileSearch.addEventListener("keydown", (e)=>{
        if(e.key === "Escape"){
          mobileSearch.value = "";
          if(mobileSearchResults){
            mobileSearchResults.innerHTML = "";
            mobileSearchResults.classList.remove("open");
          }
          mobileSearch.blur();
        }
      });
    }

    if(mobileSearchResults){
      mobileSearchResults.addEventListener("click", (e)=>{
        const item = e.target && e.target.closest ? e.target.closest(".m-sr-item") : null;
        if(!item) return;
        const id = item.getAttribute("data-id");
        const maps = buildMaps(pool());
        if(maps.byId.has(id)){
          selectedId = id;
          stack = pathToRoot(id, maps.byId);
          // hide results
          if(mobileSearchResults){
            mobileSearchResults.classList.remove("open");
            mobileSearchResults.innerHTML = "";
          }
          if(mobileSearch) mobileSearch.value = "";
          renderMobile();
        }
      });
    }

    // tap outside results closes
    document.addEventListener("click", (e)=>{
      if(!document.body.classList.contains("mobile-mode")) return;
      const within = e.target && (e.target.closest && (e.target.closest("#mobileSearchResults") || e.target.closest("#mobileSearch")));
      if(!within){
        try{
          if(mobileSearchResults) mobileSearchResults.classList.remove("open");
        }catch(_e){}
      }
    }, true);
  }

  function renderMobile(){
    if(!document.body.classList.contains("mobile-mode")) return;

    const list = pool();
    const maps = buildMaps(list);
    if(!selectedId || !maps.byId.has(selectedId)){
      const r = findRoot(maps.byId);
      selectedId = r;
      stack = r ? [r] : [];
    }
    const p = maps.byId.get(selectedId);
    if(!p) return;

    // Back button
    const backBtn = document.getElementById("mobileBack");
    if(backBtn) backBtn.style.display = (stack.length > 1) ? "inline-flex" : "none";

    // Path
    const pathEl = document.getElementById("mobilePath");
    if(pathEl){
      const names = stack.map(id => (maps.byId.get(id)?.name || id)).filter(Boolean);
      pathEl.textContent = names.join("  ›  ");
    }

    // Card header
    const nameEl = document.getElementById("mCardName");
    const titleEl = document.getElementById("mCardTitle");
    if(nameEl) nameEl.textContent = p.name || "";
    if(titleEl) titleEl.textContent = p.title || "";

    // Avatar
    const img = document.getElementById("mPhoto");
    const ini = document.getElementById("mInitials");
    const initials = (p.name||"").trim().split(/\s+/).slice(0,2).map(s=>s[0]||"").join("").toUpperCase() || "??";
    if(img && ini){
      if(p.photo){
        img.src = p.photo;
        img.style.display = "block";
        ini.style.display = "none";
        img.onerror = ()=>{ img.style.display="none"; ini.textContent = initials; ini.style.display="block"; };
      }else{
        img.style.display = "none";
        ini.textContent = initials;
        ini.style.display = "block";
      }
    }

    // Badges
    const badges = document.getElementById("mCardBadges");
    if(badges){
      const mgr = maps.byId.get(getReportsTo(p) ? String(getReportsTo(p)).trim() : "");
      const chips = [];
      if(p.department) chips.push('<div class="m-chip"><strong>DEPT</strong> '+escapeHtml(p.department)+'</div>');
      chips.push('<div class="m-chip"><strong>REPORTS TO</strong> '+escapeHtml(mgr ? (mgr.name||"—") : "—")+'</div>');
      badges.innerHTML = chips.join("");
    }

    // Direct reports list
    const repWrap = document.getElementById("mobileReports");
    if(repWrap){
      const kids = (maps.kids.get(p.id) || []).slice();
      if(!kids.length){
        repWrap.innerHTML = '<div style="opacity:.72;font-size:13px;padding:10px 4px;">No direct reports.</div>';
      }else{
        repWrap.innerHTML = kids.map(cid=>{
          const c = maps.byId.get(cid) || {};
          const ini2 = (c.name||"").trim().split(/\s+/).slice(0,2).map(s=>s[0]||"").join("").toUpperCase() || "??";
          const photo = c.photo ? ('<img alt="" src="'+String(c.photo).replaceAll('"',"&quot;")+'" onerror="this.style.display=\'none\'; this.parentElement.querySelector(\'.ini\').style.display=\'block\';">') : '';
          const iniHtml = '<div class="ini" style="'+(c.photo?'display:none;':'')+'">'+escapeHtml(ini2)+'</div>';
          return '<div class="m-report" data-id="'+String(c.id).replaceAll('"',"&quot;")+'">' +
                   '<div class="ra">'+ photo + iniHtml + '</div>' +
                   '<div class="txt"><div class="n">'+escapeHtml(c.name||"")+'</div><div class="t">'+escapeHtml(c.title||"")+'</div></div>' +
                   '<div class="chev">›</div>' +
                 '</div>';
        }).join("");
      }

      repWrap.onclick = (e)=>{
        const row = e.target && e.target.closest ? e.target.closest(".m-report") : null;
        if(!row) return;
        const id = row.getAttribute("data-id");
        if(!id || !maps.byId.has(id)) return;
        selectedId = id;
        // If this target is already in stack, truncate to it; else push
        const idx = stack.indexOf(id);
        if(idx >= 0){
          stack = stack.slice(0, idx+1);
        }else{
          stack.push(id);
        }
        renderMobile();
      };
    }
  }

  function sync(forceRender){
    ensureSelected();
    if(forceRender) renderMobile();
  }

  // Expose sync hook for CSV loads / uploads
  window.__MOBILE_SYNC__ = function(){
    try{ if(document.body.classList.contains("mobile-mode")) sync(true); }catch(e){}
  };

  function handleResize(){
    setMode(wantsMobile());
  }

  // Boot
  window.addEventListener("resize", handleResize);
  window.addEventListener("orientationchange", handleResize);
  // initial
  setMode(wantsMobile());
})();
</script>

</body>

</html>
